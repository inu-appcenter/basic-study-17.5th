---
# 쿠키와 세션
---
## 1. HTTP 프로토콜의 특징

### 프로토콜
컴퓨터 내부 혹은 컴퓨터 사이에서의 데이터를 교환하는 방식을 정한 규칙

### HTTP 프로토콜
HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜

### 클라이언트 - 서버 프로토콜 (HTTP 프로토콜)
수신자 측(웹 브라우저)의 요청에 의해 완전한 html 문서를 불러오고(fetch) 이후 하위 문서들(텍스트, 레이아웃 설명, 이미지, 비디오, 스크립트 등)로 재구성됨

메세지 교환 방법
1. request: 클라이언트(브라우저)에 의해 전송되는 메시지
2. response: request를 받은 서버에서 응답으로 전송되는 메시지

### HTTP 프로토콜의 특징
- connectionless: 클라이언트가 요청하고 서버가 응답하면 연결을 끊어버림
- stateless: 통신이 끝나면 상태를 유지하지 않음 (클라이언트 정보 유실)
- connectionless / stateless한 특성을 해결하기 위해 쿠키와 세션을 사용함.

## 2. 쿠키란? (정의, 특징, 종류)

### 쿠키
서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각

### 쿠키의 용도
- 세션 관리(서버가 알아야 할 내용 저장)
- 개인 설정 유지(예시> 쇼핑몰 장바구지 정보 저장, 개인 맞춤 콘텐츠 제공)
- 사용자 트래킹(사용자의 행동을 기록하고 분석)
- 성능 개선 (기본 값 저장 -> 반복적인 연산 필요 x)

### 쿠키의 종류
- **세션 쿠키**: 세션 종료 시 삭제
- **영속 쿠키**: 쿠키 보존 기간 설정 가능
- **1st 쿠키**: 클라이언트가 요청한 사이트로부터 생성된 쿠키
- ![](https://velog.velcdn.com/images/dlwjd8023/post/a2647a67-99ef-4f4c-8720-c4fef10520f1/image.png)
**3rd 쿠키**: 제 3자가 생성한 쿠키(타 도메인, 광고, 사용자 트래킹 목적)

### 쿠키의 특징
- 한 개에 데이터를 4KB까지 저장 가능하고, 하나의 도메인 당 최대 20개, 총 최대 300개까지 저장 가능
- **클라이언트(브라우저)에 저장**
- 이름, 값, 만료날짜, 경로 정보 등의 정보 저장
- 웹 브라우저를 종료시키면 소멸 (**만료날짜 지정 가능**, 지정 시 브라우저의 종료 여부와 상관없이 해당 기한까지 쿠키 유지)
- 웹 브라우저에 해당 서버의 쿠키 정보가 있으면 HTTP request (HTTP header cookie)에 담아 보냄

### 쿠키의 작동 방식
HTTP request와 response에 따라 작동
![](https://velog.velcdn.com/images/dlwjd8023/post/5b5923e2-2dac-40e4-bfd5-0fbe43fa30a4/image.png)

1. 클라이언트가 서버에 요청(request)을 보냄
2. 서버에서 쿠키를 생성하여 HTTP 헤더에 담은 뒤, 클라이언트에 반환(resonse)
2. 쿠키를 받은 클라이언트는 도메인 서버 이름으로 정렬된 쿠키 디렉토리에 쿠키를 저장
3. 이후 클라이언트가 동일한 서버로 HTTP 요청을 보내면 HTTP 헤더에 쿠키를 함께 담아 보냄
4. 서버에서 쿠키에 업데이트된 내용이 있으면 응답할 때 업데이트해서 보냄

### 쿠키의 사용 예
- 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
- 쇼핑몰의 장바구니 기능
- 자동로그인, 팝업에서 "오늘 더 이상 이 창을 보지 않음" 체크

## 3. 세션이란? (정의, 특징, 세션ID 흐름)

### Session - 시간, 시즌
통신을 하기 위해 서로 연결된 순간부터 통신을 마칠 때까지의 기간

### HTTP 세션
- 사전적 정의: 클라이언트가 웹 서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 통신을 끝낼 때까지의 기간
- 용어적 정의: 서버에 세션에 대한 정보를 저장해두고, 세션 쿠키를 클라이언트에게 주어 서버가 클라이언트를 식별할 수 있도록 하는 방식
- **"서버에서 관리하는 쿠키"**

### 세션의 특징
- 용량의 제한이 없음
- 서버에 세션 객체를 생성하고, 각 클라이언트마다 고유한 세션 ID 값을 부여
- 쿠키를 사용하여 세션 ID 값을 클라이언트에 전송
- **웹 브라우저가 종료되면 세션 쿠키는 삭제**
- **보안 면에서 쿠키보다 우수**
- **사용자가 많아지면 서버 메모리를 많이 차지함**

### 세션의 사용 예시
- 로그인 등 보안상 중요한 작업 수행

### 세션 ID 흐름
![](https://velog.velcdn.com/images/dlwjd8023/post/21194617-f3f3-43de-9a7e-cdd1bc2bcffb/image.png)

1. 클라이언트가 서버에 요청을 보내면 서버에서 요청 헤더(쿠키)를 확인하고 세션 ID를 확인함
2. 요청에 세션 ID가 없다면 새로 생성한 뒤 쿠키에 세션 ID를 담아 응답함 (서버에서 세션 객체를 생성하여 정보 저장.)
3. 클라이언트는 응답으로 받은 세션 쿠키(세션 ID)를 저장하고, 매번 해당 서버에 요청을 보낼 때마다 세션 쿠키를 함께 보내 자신을 인증함
4. 브라우저가 종료되면 세션 쿠키는 소멸됨

## 4. 쿠키와 세션의 관계

### 세션은 쿠키를 이용하는 하나의 방식임
- 쿠키는 HTTP 통신에서 클라이언트에 정보(표시)주어 해당 클라이언트를 식별할 수 있게 하고, 클라이언트에 정보를 저장함
- 세션은 서버에 정보를 생성/저장하고, 다시 이 정보를 담아 클라리언트에 응답함으로써 다음 요청시 이를 확인하여 클라이언트를 식별함
- 보안의 관점으로 볼 때, 브라우저 쿠키는 확인이 용이하므로, 중요한 정보의 유출 위험이 높음.(계정 아이디/비밀번호 등) -> 중요한 정보는 세션쿠키로써 서버가 관리하여 보안을 유지하고, 세션 쿠키로는 클라이언트를 식별 

## 5. 쿠키와 세션의 차이점
1. 관리: 쿠키는 클라이언트에서 관리 <-> 세션은 서버에서 관리
2. 내용: 쿠키는 비교적 가벼운 정보(장바구니, 개인 설정)에 사용 <-> 세션은 무거운 정보(로그인 유지 등)에 사용
3. 보존기간: 쿠키는 만료기간 설정 시 브라우저 종료 시에도 데이터 유지 <-> 세션은 만료기간을 설정해도 브라우저 종료 시 소멸

---
# 세션 기반 인증 / 토큰 기반 인증
---
## 0. 인증과 인가
시스템의 자원을 적절하고 유효한 사용자에게 전달하고 공개하는 방법

### 인증(Authentication)
클라이언트가 자신임을 주장하는 사용자가 맞는지 검증하는 과정
예시: 로그인 화면에서 아이디와 패스워드를 입력하고, 서버가 확인

### 인가(Authorization)
인증된 사용자에 대한 자원의 접근 확인 절차
예시: User1은 User2의 게시물을 수정 / 삭제할 수 없고, 관리자 페이지에 접근할 수 없음

## 1. 세션 기반의 인증 흐름

### 세션 기반 인증
사용자의 인증 정보가 서버의 세션 저장소에 저장되는 방식

### 인증 흐름
![](https://velog.velcdn.com/images/dlwjd8023/post/dfa700a1-fd9b-4b3f-bbbf-988b91384766/image.png)

1. 사용자가 서버에 로그인 (서버에 인증)
2. 서버는 인증 정보를 세션에 저장하고, 저장된 세션 정보의 식별자인 Session ID를 발급 및 반환
3. 발급된 Session ID는 브라우저에 쿠키로 저장, but 실제 인증 정보는 서버에 저장
4. 브라우저는 인증 절차 뒤의 요청마다 HTTP Cookie 헤더에 Session ID를 담아 서버로 전송
5. 서버는 요청을 전달받고, Session ID에 해당하는 세션 정보가 세션에 존재하면, 해당 사용자를 인증된 사용자로 판단.

## 2. 토큰 기반의 인증 흐름

### 토큰 기반 인증
- 인증 정보를 클라이언트가 직접 가지는 방식
- 인증 정보는 토큰의 형태로 브라우저의 로컬/세션/쿠키에 저장

### 토큰의 종류
- 엑세스 토큰: 인증 정보를 담고 있는 토큰, 짧은 기간동안 지속 (15분 내외)
- 리프레시토큰: 엑세스토큰을 발급하기위한 2차 토큰

### 인증 흐름
![](https://velog.velcdn.com/images/dlwjd8023/post/22e64a8d-989c-4d3a-82c1-2d461dbca3b6/image.png)

1. 유저가 서버에 로그인(인증)
2. 서버는 토큰(JWT) (+ 서버의 비밀 키)를 생성하여 클라이언트에 전달
3. 이후 동일한 서버에 요청 시, 토큰을 HTTP Auhorization 헤더에 담아 전달
4. 서버는 토큰의 위변조/만료 여부를 확인한 후, 토큰에 담긴 사용자 인증 정보를 확인해 사용자를 인증

## 3. 세션 기반 인증 vs 토큰 기반 인증

### 트래픽
- 세션 기반 인증: HTTP Cookie 헤더에 세션 ID만 보냄 -> 트래픽 사용량이 적음
- 토큰 기반 인증: 상대적으로 많은 정보 사용(사용자 인증 정보, 토근 발급/만료 시각, 토큰 ID, etc)

### 안전성
- 세션 기반 인증: 모든 인증 정보를 서버에서 관리 -> 보안 유리
- 토큰 기반 인증: 클라이언트가 모든 인증정보를 소유 -> 토큰 정보 유출 시 피해

### 확장성
- 세션 기반 인증: 여러 대의 서버에 요청 분산 처리-> 세션 불일치 문제에 취약
- 토큰 기반 인증: 클라이언트가 직접 정보 소유 -> 세션 불일치 문제로부터 자유로움

### 세션 불일치 문제
여러 대의 서버를 운용해 부하를 분산시킬 때, 각 서버에 세션을 저장하여 클라이언트 요청이 다른 서버로 갈 경우, 세션 데이터를 찾을 수 없는 상황

### 예시
![](https://velog.velcdn.com/images/dlwjd8023/post/c97dcd87-e725-4506-b584-1e74560208d9/image.png)
- **로드 밸런서(Load Balancer)**: 클라이언트의 요청을 여러 서버로 분산하여 특정 서버의 부하를 줄이고 서비스의 가용성 및 응답 시간을 최적화하는 장치 또는 서비스

1. 1번 서버에 Login
2. 3번 서버에 로그인 후 할 수 있는 작업에 대한 API 요청
3. 3번 서버에서는 로그인 상태를 확인할 수 있는 세션정보가 없음
4. 로그인이 되지 않은 것으로 판단

## 4. JWT의 구조
### JWT(Json Web Token)
인증에 필요한 정보들을 암호화시킨 JSON 토큰

### JWT 기반 인증
JWT 토큰을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식(위에서 설명한 토큰 인증 흐름)

### JWT의 구조
![](https://velog.velcdn.com/images/dlwjd8023/post/593d45f4-c750-410d-97b6-c87b3c006639/image.png)

- `.`을 기준으로 구분
- Header: 토큰 자체를 설명
   - alg:: 서명 암호화 알고리즘
   - typ: 토큰 유형
- Playload: 전달하고자 하는 내용
   - iss(issuer): 발행자
   - exp(expiration): 만료 시간
   - sub(subject): 제목
   - iat(issued at): 발행 시간
   - jti: JWT ID
- Signature: 토큰의 무결성 확인
   - 헤더 + 페이로드, 서버에서 가진 key값을 합친 뒤, header에서 정의한 알고리즘으로 암호화 -> 후에 서명됨

## 5. 토큰 저장 위치 (로컬/세션/쿠키)

### 로컬 스토리지
- 브라우저를 새로고침해도 정보 유지 -> 사용자 편의 
- JavaScript 코드를 통해 접근 가능 -> 보안 취약

### 세션 스토리지
- 현재 떠 있는 탭에 한해서 유지 -> 탭을 닫고 열면 데이터 소실 (새로고침 시는 소실x)
- JavaScript 코드를 통해 접근 가능 -> 보안 취약

### 쿠키 스토리지
- 기본적으로 JavaScript 코드를 통해 접근 가능 -> 보안 취약
- **But**, 백엔드와의 협업으로 서버 측에서 HTTP Only, Secure, Samesite 등의 옵션을 설정 -> 쿠키 탈취 / JS 접근 제한 가능
- 매번 HTTP 헤더에 포함되어 트래픽 증가

---
# 실무에서 사용하는 인증 방식
---
## 세션 기반 인증 방식
### 장점
- 높은 보안성: 사용자 인증 정보가 서버 측에 저장 -> 정보 유출 감소
- 중앙 집중 관리: 서버에서 사용자 세션 관리 -> 사용자 인증 및 접근 제어 용이

### 단점
- 서버 부하 및 확장성 문제: 모든 세션 정보를 서버가 관리 -> 대규모 트래픽 발생 시 서버 메모리 사용 과부하, 복잡화
- 서버 장애 시 문제: 서버 재부팅 시 세션 정보 손실
- 세션 ID 유출 시 보안 위험

### 사용처: 일반적인 웹 사이트
- 브라우저에서 자동으로 쿠키 관리
- 관리자 페이지에서 사용자 관리 용이

## 토큰 기반 인증 방식
### 장점
- 서버 부하 감소: 사용자 정보를 클라이언트가 저장 -> 서버 부하 감소
- 확장성: 여러 서버 간 인증 상태 공유 용이
- 모바일 및 다른 API와의 연동 용이: 사용자 정보를 클라이언트가 저장 -> 모바일 앱 / API 연동 용이

### 단점
- 보안 -> 토큰 탈취 시 보안에 취약 -> 서버 자체 옵션 설정 등으로 백엔드와의 협업 필요
- 토큰 관리 -> 클라이언트 측에서 토큰의 유효 기간과 갱신 로직 관리

### 사용처: 웹 앱/모바일 앱
- 분산 서버 환경
- 확장성
- 모바일 앱은 쿠키 자주 관리 X

---
# 캐시
---
## 1. 캐시란?
자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소

### 하드웨어적 의미의 캐시
![](https://velog.velcdn.com/images/dlwjd8023/post/dea757e9-36cf-4202-bb66-711d36e6d125/image.png)

거리상으로 각 캐시는 메인메모리보다 CPU에 더 가깝다 -> 더 빠르고 효율적인 연산 가능

### 캐시의 장점
- 반복 연산 시 캐시에 저장된 데이터를 사용하여 작업 효율화
- 유용하거나, 연산이 많이 필요하거나, 접근하는 시간이 오래 걸리는 데이터를 미리 가져와 작업 효율화

### 웹 캐시의 종류
#### 브라우저 캐시
- 클라이언트에 의해 내부 디스크에 캐시 저장
- 한 개인의, 한정된 캐시
- 브라우저의 뒤로가기나 이미 방문한 페이지를 재방문하는 경우에 용이
 
#### 프록시(클라이언트-서버의 중계자(물리/가상서버)) 캐시
- 브라우저 캐시와 와 동일한 원리로 동작하며 클라이언트나 서버가 아닌 네트워크 상에서 동작
- 큰회사의 방화벽에 설치
- 대기시간 & 트래픽 감소, 접근정책 & 제한 우회, 사용률 기록 등을 수행
- 한정된 수의 클라이언트을 위하여 무한대의 웹서버의 컨텐츠를 캐시에 저장
- 방화벽: 미리 결정된 보안 규칙에 따라 수신 및 발신 네트워크 트래픽을 모니터링, 필터링 및 제어하도록 설계된 네트워크 보안 장치

#### 게이트웨이 캐시 
- 서버 앞 단에 설치
- 요청에 대한 캐쉬 및 효율적인 분배를 통해 가용성, 신뢰성, 성능등을 향상
- 암호화, 부하 관리, 압축 등을
- 무한대의 클라이언트들에게 한정된 수의 웹서버 컨텐츠를 제공


### 캐시 컨트롤
웹 브라우저가 특정 리소스에 최초 요청을 했을 때, 서버는 `Cache-Control` 헤더가 포함된 응답을 보냄

> HTTP/1.1 200 OK //HTTP Verb: 응답 상태
Content-Type: text/html // 컨텐츠 타입: html 문서
Cache-Control: max-age=3600 // 유지시간(초 단위)
Content-Length: 157 // 컨텐츠 길이

이후 웹 브라우저가 같은 리소스에 요청을 보내면, 실제 웹 서버에 요청을 보내는 것이 아니라 캐시에 저장된 사본 데이터를 사용자에게 제공

## 2. 캐시를 사용하는 이유
- 빠른 응답 속도: 원본 데이터에 접근하는 것보다 캐시에서 데이터를 가져오는 것이 훨씬 빠름
- 서버 부하 감소: 반복적인 데이터 요청에 대해 캐시된 데이터를 제공하여 데이터베이스나 서버에 가해지는 부하를 줄임
- 네트워크 트래픽 절감: 이미지, CSS 등의 파일을 캐시에 저장해 다시 다운로드할 필요가 없어 네트워크 대역폭 사용을 줄임
- 서버 리소스 절약: 서버가 데이터를 직접 처리하는 대신 캐시된 데이터를 빠르게 제공해 서버의 CPU 및 메모리 등의 리소스 사용량이 줄어듬
---
