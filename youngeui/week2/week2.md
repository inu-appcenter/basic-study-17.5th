# week2 내용 발표 자료

### 1. 명령어 정리

- **되돌리기**
    
    >> Git에서 되돌리기는 크게 [커밋](https://www.notion.so/commit-279658ff3fb980d3a9dde795095447fb?pvs=21) 자체를 되돌리는 방법, [스테이징/워킹 디렉토리](https://www.notion.so/279658ff3fb980868054d79c595f0685?pvs=21)를 되돌리는 방법으로 나눌 수 있다.
    
    1. `git reset [옵션] [commit]`
    
    **: 커밋을 지우거나, 스테이징/워킹 디렉토리를 이전 상태로 되돌리는 명령**
    
    - 여기서 commit은 되돌아가고 싶은 목표 커밋
    - 옵션에 따라 되돌리는 범위가 달라짐
        - `—soft` : 커밋만 되돌림. 스테이징 영역은 유지
        - `—mixed` : 커밋 + 스테이징 되돌림. 워킹 디렉토리는 유지
        - `—hard` : 커밋 + 스테이징 + 워킹 디렉토리 모두 되돌림
    
    ** reset은 기록을 지우기 때문에 주의해야함
    
    1. `git revert [commit]`
    
    **: 특정 커밋을 되돌리는 새로운 커밋을 만드는 명령**
    
    - 되돌리고 싶은 커밋의 해시 필요 ⇒ `git revert [commit-hash]`
    - 원래 커밋을 그대로 두고, 반대로 적용된 새 커밋을 만들어서 안전하게 되돌릴 수 있음
    
    ** 협업 때 안전 ⇒ 기록이 남음
    
    - 시각화
        
        
        ![처음 상태](week2%20%EB%82%B4%EC%9A%A9%20%EB%B0%9C%ED%91%9C%20%EC%9E%90%EB%A3%8C%20279658ff3fb980dcab65c06ccb959826/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.55.30.png)
        
        처음 상태
        
        ![스크린샷 2025-09-26 오후 6.06.55.png](week2%20%EB%82%B4%EC%9A%A9%20%EB%B0%9C%ED%91%9C%20%EC%9E%90%EB%A3%8C%20279658ff3fb980dcab65c06ccb959826/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.06.55.png)
        
    
    **[ reset** vs **revert ]**
    
    reset은 커밋을 아예 삭제 (기록 자체가 없어짐) ⇒ 위험
    
    revert는 해당 커밋을 남겨놓되, 되돌린 커밋을 새로 만듦 (기록은 남김) ⇒ 안전
    
    1. `git restore [파일명]`
    
    **: 워킹 디렉토리나 스테이징 영역의 변경 내용을 되돌릴 때 사용하는 명령**
    
    - 파일을 마지막 커밋 상태로 되돌림
    - 스테이징 영역만 되돌릴 때는 `—staged` 옵션 사용 ( ex. `git restore —staged [파일명]` )
        
        ** 주로 실수로 스테이징한(git add) 변경 사항을 제거할 때 사용
        
    
- **커밋 수정**
    1. `git commit —amend`
    
    **: 마지막 커밋을 수정하는 명령**
    
    - 메시지를 바꾸거나, 커밋에 빠뜨린 파일을 추가할 때 사용
    - 사용법
        1.  **커밋 메시지 수정**
        
        >> `git commit —amend -m “새 메시지”`
        
        1.  **파일 추가 후 커밋 수정**
        
        >> `git add [파일명]` → 수정하거나 추가한 파일을 스테이징
        
        >> `git commit —amend` → 마지막 커밋에 합치기
        
- **[브랜치](https://www.notion.so/branch-279658ff3fb980708a5bdf93d6ae4e82?pvs=21) 관리**
    1. `git merge`
    
    **: 두 브랜치의 변경 사항을 합치는 명령**
    
    - Fast-forward merge : 브랜치가 직선상에 있을 때, 단순히 포인터 이동 → 병합 커밋 없음
    - 3-way merge : 브랜치가 갈라져 있을 때, 새 병합 커밋 생성 → 병합 커밋 있음
    
    ** 히스토리 보존, 충돌 발생 시 쉽게 추적 가능
    
    - ex. 3-way merge
        
        메인 브랜치(main) : A — B — C, 현재 브랜치(feature) : B — D
        
        `git merge feature` 하면 main 브랜치에 feature 브랜치의 변경사항 **D**를 병합 → 3-way merge 발생
        
        따라서 결과 ⇒ main : A — B — C — **F**(병합커밋)
        
    - 시각화
        
        
        ![처음 상태](week2%20%EB%82%B4%EC%9A%A9%20%EB%B0%9C%ED%91%9C%20%EC%9E%90%EB%A3%8C%20279658ff3fb980dcab65c06ccb959826/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.03.18.png)
        
        처음 상태
        
        ![스크린샷 2025-09-26 오후 4.46.05.png](week2%20%EB%82%B4%EC%9A%A9%20%EB%B0%9C%ED%91%9C%20%EC%9E%90%EB%A3%8C%20279658ff3fb980dcab65c06ccb959826/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.46.05.png)
        
    
    1. `git rebase`
    
    **: 브랜치의 커밋을 다른 브랜치 위로 재배치하는 명령**
    
    - 히스토리를 직선으로 깔끔하게 유지할 때 사용
    - merge 커밋 없이 브랜치 기록 직선화
    
    ** 히스토리 깔끔, 충돌 해결 시 브랜치별로 단계별 처리 가능
    
    ** 협업 중인 브랜치 rebase 시, 팀원에게 영향 → 주의
    
    ** 이미 원격 저장소에 push한 커밋을 rebase 했다면 → `git push —f` 필요
    
    - 시각화
        
        
        ![스크린샷 2025-09-28 오후 5.19.49.png](week2%20%EB%82%B4%EC%9A%A9%20%EB%B0%9C%ED%91%9C%20%EC%9E%90%EB%A3%8C%20279658ff3fb980dcab65c06ccb959826/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.19.49.png)
        
        ![스크린샷 2025-09-26 오후 4.52.48.png](week2%20%EB%82%B4%EC%9A%A9%20%EB%B0%9C%ED%91%9C%20%EC%9E%90%EB%A3%8C%20279658ff3fb980dcab65c06ccb959826/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.52.48.png)
        
    
    **[ merge** vs **rebase ]**
    
    merge는 브랜치를 **합치는 것** → 분기 구조 유지 (병합 커밋 O)
    
    rebase는 브랜치를 **재배치** → 히스토리 직선화 (병합 커밋 X)
    
    1. `git cherry-pick [commit]`
    
    **: 특정 커밋만 선택해서 현재 브랜치에 적용하는 명령**
    
    - 브랜치 전체를 합치지 않고, 필요한 커밋만 반영할 때 사용
    
    ** 충돌 발생 가능
    
    ** 여러 브랜치에서 같은 커밋을 cherry-pick하면 커밋 해시가 달라짐
    
    - ex.
        
        main : A — B — C, feature : D — E
        
        `git cherry-pick D` 하면 결과는 
        
        ⇒ main : A — B — C — D, feature : D — E
        
    
- **작업 임시 저장**
    1. `git stash`
    
    **: 작업 중인 변경 사항을 임시로 숨겨두는 명령**
    
    - 브랜치를 바꾸거나, 긴급히 다른 작업을 해야 할 때 유용
    - 예를 들어, feature 브랜치에서 작업 중 급히 main 브랜치로 이동해야할 때, 아직 커밋하지 않은 변경사항이 있을 경우 → stash 사용
    - 사용법
        1. 변경 사항 임시 저장 
            
            : 워킹 디렉토리 + 스테이징 영역의 변경사항을 stash에 저장 → 저장 후 브랜치는 마지막 커밋 상태로 돌아감
            
            - `git stash`
            - `git stash save “작업 내용 설명”` : 설명 추가 할 때
        2. stash 목록 확인
            - `git stash list`
        3. stash 적용
            - `git stash apply` : 가장 최근 stash 적용
            - `git stash apply stash@{1}` : 특정 stash 적용
        4. stash 삭제
            - `git stash drop stash@{1}` : 특정 stash 삭제
            - `git stash pop` : apply + drop
            
- **** HEAD**
    1. **HEAD**
    
    **: 현재 cheakout된 브랜치가 가리키는 최신 커밋을 가리키는 포인터 ⇒ 현재 작업 중인 브랜치**
    
    - ex.
        
        main (현재 브랜치) : A — B — C ⇒ ****HEAD = **C**
        
        이후 커밋하면 HEAD가 가리키는 브랜치 위에 새로운 커밋이 쌓임
        
    
    1. **Detached HEAD**
    
    **: HEAD가 브랜치가 아닌 특정 커밋을 가리킬 때**
    
    - 브랜치가 아닌 커밋을 cheakout ⇒ `git cheakout [commit-hash]`
    - 특징
        - 브랜치에 연결되어 있지 않음
        - 새 커밋은 기존 브랜치 히스토리에 포함되지 않음
        - 브랜치를 생성하지 않으면, 나중에 커밋을 잃어버릴 수 있음
        
        ** 안전하게 작업하려면 → 새 브랜치를 만들고 현재 HEAD 커밋부터 이어서 작업 ⇒ `git checkout -b new-branch`
        
    - 시각화
        
        
        ![처음 상태](week2%20%EB%82%B4%EC%9A%A9%20%EB%B0%9C%ED%91%9C%20%EC%9E%90%EB%A3%8C%20279658ff3fb980dcab65c06ccb959826/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.36.40.png)
        
        처음 상태
        
        ![스크린샷 2025-09-26 오후 5.37.17.png](week2%20%EB%82%B4%EC%9A%A9%20%EB%B0%9C%ED%91%9C%20%EC%9E%90%EB%A3%8C%20279658ff3fb980dcab65c06ccb959826/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.37.17.png)
        

### 2. 브랜치 전략

**: 프로젝트를 여러 개발자가 함께 진행할 때, 브랜치를 어떤 규칙으로 만들고, 병합하고, 삭제할지 정해 놓은 방법론**

- **Git Flow**
    
    : 전통적이고 체계적인 브랜치 전략 → 대규모 프로젝트에서 많이 사용됨. 
    
    ** 안정적
    
    - 주요 브랜치
        - main : 실제 서비스 되고 있는 안정 버전
        - develop : 다음 배포를 준비하는 개발 버전
        - feature : 새로운 기능 개발용 브랜치 → 작업 끝나면 develop으로 병합
        - release : 배포 준비용 브랜치, 버그 수정 → 작업 끝나면 main + develop에 병합
        - hotfix : 운영 중 긴급 수정할 때 사용 → 수정 후 main + develop에 병합
        
        <aside>
        💡
        
        main ← release ← develop ← feature
        
        main ← hotfix
        
        </aside>
        
    
- **GitHub Flow**
    
    : 간단한 브랜치 전략 → 배포 주기가 짧고, 빠른 팀(스타트업)에 적합
    
    ** 비교적 단순
    
    - 기본 원칙
        1. main 브랜치는 항상 배포 가능한 상태
        2. 새로운 작업은 feature 브랜치에서 시작
        3. 작업이 끝나면 Pull Request(PR) 생성 → 리뷰/테스트 후 main에 병합
        4. 병합되면 자동으로 배포하는 경우 많음
        
        <aside>
        💡
        
        main ← feature
        
        (PR → 코드 리뷰 → merge)
        
        </aside>
        

### 3. GitHub 협업

- **GitHub 협업 흐름**
    
    <aside>
    💡
    
    Issue → Branch → Commit → Push → PR → Merge
    
    </aside>
    
    1. **Issue 생성**
        - 해야 할 작업을 GitHub Issue에 등록
    2. **Branch 생성**
        - Issue별로 브랜치 생성
        - main을 직접 건드리지 않음
    3. **Commit 작성**
        - 변경 사항을 커밋으로 저장
        - 커밋 메시지
    4. **Push**
        - 로컬 브랜치를 GitHub 원격 저장소에 푸시
        - `git push origin [브랜치명]`
    5. **Pull Request (PR)**
        
        : 협업 과정에서 코드 변경을 다른 브랜치(주로 main)에 합치고 싶을 때 요청하는 절차
        
        - GitHub에서 PR 생성 → 팀원들이 코드 리뷰
    6. **Merge**
        - 최종적으로 main 브랜치에 병합
        - Merge 방식은 여러 전략 중 선택 가능
        
- **Merge 전략**
    1. **Fast-forward**
        - 브랜치가 직선상에 있을 때
    2. **3-way Merge**
        - 브랜치가 갈라졌을 때
    3. **Squash Merge**
        - feature 브랜치의 여러 커밋을 하나의 커밋으로 합쳐서 main에 넣음
        - main은 깔끔해지지만, feature의 세부 커밋 히스토리는 사라짐
    4. **Rebase Merge**
        - git rebase와 유사 → feature 브랜치 커밋들을 main 위로 다시 쌓음

### 4. 충돌(Conflict)

- **충돌이 일어나는 이유**
    
    **: 다른 브랜치에서 동일한 파일, 동일한 코드 줄을 작업할 경우 발생** 
    
    ⇒ 따라서 커뮤니케이션이 중요
    
- **충돌 발생**
    - 충돌이 발생했을 때 Git이 표시하는 방식
    
    ```
    <<<<<<< 현재 브랜치
    (내용)
    ======= : 구분선
    (내용)
    >>>>>>> 합치려는 브랜치
    ```
    
    - 충돌 해결 방법
        1. 충돌 발생 확인 : `git status`를 통해 충돌이 발생한 파일 확인
        2. 충돌이 발생한 파일을 텍스트 편집기로 열기
        3. 충돌 부분 수정 : 
            1. 충돌이 발생한 부분의 내용을 삭제하거나 합치거나 수동으로 수정
            2. 수정 후 <<<<<<<, =======, >>>>>>> 마커 제거
        4. 수정 후 Git에게 알려주기 :
            1. `git add [파일명]`
            2. `git commit -m “Resolve merge conflict”`
        

### 5. 커밋 컨벤션

**: 커밋 메시지를 일정한 형식으로 작성하는 규칙**

<aside>
💡

type: 설명

</aside>

- **Commit Type**
    - feat : 새로운 기능 추가
    - fix : 버그 수정
    - docs : 문서 수정
    - style : 코드 포맷, 세미콜론 누락, 공백 등 (기능 변경 없음)
    - refactor : 코드 리팩토링 ⇒ 기능은 그대로 두고 코드를 더 깔끔하게, 효율적으로 바꾸는 작업 (버그 수정/기능 추가 없음)
    - test : 테스트 코드 추가/수정
    - chore : 빌드 업무, 패키지 매니저 설정 등 잡다한 작업