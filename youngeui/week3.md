# week3 내용 발표 자료

### 1. 쿠키와 세션

- **HTTP 프로토콜의 특징**
    
    > **HTTP 프로토콜**이란 웹에서 클라이언트와 서버가 정보를 주고받는 규칙
    
    1. **클라이언트-서버 구조**
        - 클라이언트가 요청(Request)을 보내면 서버가 요청에 대한 응답(Response)을 보내는 구조
    2. **비연결성 (Connectionless)**
        - 요청과 응답을 한 번씩 처리하고 연결을 끊는 방식 ⇒ 최소한의 자원으로 서버 유지 가능
        - 장점 : 서버 입장에서 부하를 줄일 수 있음 → 동시에 더 많은 클라이언트의 요청을 처리
        - 단점 : 한 클라이언트가 여러 요청을 보낼 경우, 연결이 매번 새로 생성되고 종료됨 → 서버는 이전에 누가 요청을 보낸건지 알 수 없음
        - 예시:
            1. 브라우저가 웹 서버에 요청
            2. 서버가 응답 → 바로 연결 종료
    3. **무상태성 (Stateless)**
        - 클라이언트가 이전에 어떤 요청을 했는지 기억 X ⇒ 서버가 클라이언트의 상태를 저장 X
        - 예시:
            - 오늘 로그인한 상태인데, 새로운 페이지로 이동하면 서버는 처음 방문한 것처럼 취급
        - 상태를 유지하려면 → 쿠키나 세션, 토큰 같은 방법 필요
        
- **쿠키(Cookie)**
    
    **: 웹 서버가 클라이언트(브라우저)에 저장하는 작은 데이터**
    
    - 정의
        - 해당 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일
        - 주로 사용자 정보를 기억하고 상태를 유지하기 위해 사용
        - 브라우저는 쿠키를 저장하고, 다음과 같은 서버에 요청할 때 쿠키를 함께 전송 → 서버가 사용자를 식별 가능
    - 특징
        1. **클라이언트(브라우저)**에 저장
            - 서버가 데이터를 주지만, 실제 저장은 브라우저가 함
        2. 키(Key) - 값(Value) 형태 + 텍스트로 저장
        3. 크기 제한
            - 보통 4KB 정도, 사이트당 쿠키 개수 제한 있음
        4. 유효기간
            - 저장한 기간 동안 유지 → 없으면 브라우저 종료 시 삭제
    - 종류
        - 세션 쿠키 (Session) : 브라우저 종료 시 삭제
        - 영속 쿠키 (Persistent) : 지정된 만료일까지 유지, 재방문 가능
        - 보안 쿠키 (Secure) : HTTPS 연결에서만 전송
        - HttpOnly 쿠키 : 자바스크립트 접근 불가(클라이언트 측 접근 불가), 서버만 사용 가능
    
- **세션(Session)**
    
    **: 일정 시간동안 같은 사용자(브라우저)로부터 들어오는 여러 요청을 하나의 상태로 보고, 이를 서버가 유지하는 기술**
    
    → 일정 시간 : 웹 브라우저에 접속한 시점 ~ 브라우저를 종료하는 시점
    
    - 정의
        - 클라이언트와 서버 간의 일련의 요청을 하나의 상태로 보고, 그 상태를 일정하게 유지하는 기술
        - 클라이언트를 구분하기 위해 세션 ID를 발급하고, 이 ID를 쿠키를 통해 전달받아 사용
    - 특징
        1. **서버**에 저장
            - 상태 정보가 브라우저가 아닌 서버에 있음 → 쿠키보다 보안성 높음
        2. 세션 ID 사용
        3. 크기 제한 X
            - 서버에 저장하므로 서버 자원이 허용하는 한 크기 제한이 없음
        4. 유효기간
            - 일정 시간 동안만 유지
            - 브라우저 종료 시 삭제되는 경우도 있음
    - 세션 ID 흐름
        
        <aside>
        💡
        
        [ 클라이언트 ] → 요청 → [ 서버 ] : 세션 ID 발급
        
        ---
        
        [ 클라이언트 ] ← 세션 ID 쿠키 전달 ← [ 서버 ]
        
        ---
        
        [ 클라이언트 ] → 세션 ID 쿠키 전송 → [ 서버 ] : 세션 정보 확인
        
        </aside>
        
        1. 클라이언트 최초 접속
            - 서버가 세션 ID 생성 → 브라우저에 쿠키로 전달
        2. 클라이언트 요청 시
            - 브라우저가 세션 ID 쿠키를 서버에 전송
        3. 서버 처리
            - 세션 ID로 사용자를 식별 → 로그인 정보, 장바구니 등 상태 확인
        4. 응답
            - 서버가 필요한 데이터를 클라이언트에 전송
            
- **쿠키와 세션의 관계**
    
    **: 서버가 HTTP을 보완하기 위해 사용하는 기술 ⇒ 서버가 사용자의 상태를 기억하기 위해 함께 작동하는 관계**
    
    - 쿠키는 세션 ID를 저장하는 역할,
    - 세션은 **쿠키 속 세션 ID를 통해** 실제 사용자 정보를 관리하는 역할
    - 차이점
        
        
        | **구분** | **쿠키 (Cookie)** | **세션 (Session)** |
        | --- | --- | --- |
        | **저장 위치** | 클라이언트 (브라우저) | 서버 |
        | **저장 데이터** | 사용자 식별 정보 등 | 로그인 정보 등 사용자 상태 정보 |
        | **데이터 형식** | 텍스트 | 객체 |
        | **보안성** | 클라이언트 노출로 인해 낮음 | 서버에서 관리되므로 높음 |
        | **용량 제한** | 한 도메인 당 20개, 한 쿠키 당 4KB | 제한 없음 (서버 메모리/저장 장소 한도 내) |
        | **사용 목적** | 사용자 식별, 간단한 상태 저장 | 로그인 상태 유지, 사용자 세션 관리 |

### 2. 세션 기반 인증 / 토큰 기반 인증

- **세션 기반 인증**
    
    **: 서버가 직접 사용자의 로그인 상태를 기억하는 방식**
    
    - 흐름
        1. 로그인 요청
            - 클라이언트(브라우저)가 아이디와 비밀번호를 서버로 전송
        2. 서버 인증
            - 서버가 데이터베이스에서 사용자 정보 확인
            - 로그인 성공 시 세션 생성
                - 서버는 인증된 사용자의 정보를 세션 저장소에 기록
                - 동시에 세션 ID 생성
        3. 세션 ID 전달
            - 서버는 세션 ID를 쿠키 형태로 클라이언트에 전달
            - 브라우저는 자동으로 이 쿠키를 로컬에 저장
        4. 이후 요청
            - 클라이언트가 다음 요청을 보낼 때마다 브라우저는 쿠키에 저장된 세션 ID를 자동으로 포함해서 서버로 전송
        5. 서버 인증 확인
            - 서버는 받은 세션 ID를 세션 저장소에서 찾아보고 일치하는 세션이 있으면 인증된 사용자로 판단 → 요청 처리 진행
        6. 로그아웃 or 세션 만료
        
- **토큰 기반 인증**
    
    **: 서버가 사용자의 상태를 저장하지 않고, 암호화된 토큰(Token)을 사용하여 인증하는 방식**
    
    - 흐름
        1. 로그인 요청
            - 사용자가 ID와 PW를 입력하고 서버에 로그인 요청을 보냄
        2. 서버 인증
            - 서버는 DB에 저장된 정보를 바탕으로 ID/PW가 일치하는지 확인
        3. 토큰 발급
            - 로그인 성공 시, 서버는 사용자 정보를 바탕으로 토큰을 생성 → 주로 JWT 형식 사용
        4. 클라이언트 저장
            - 클라이언트는 받은 토큰을 로컬 스토리지, 세션 스토리지 혹은 쿠키에 저장
            - 이후 요청마다 토큰을 꺼내서 함께 보냄
        5. 요청 시 인증
            - 사용자가 인증이 필요한 API 요청을 보낼 때 요청 헤더에 토큰을 담아 전송
            - 서버는 토큰을 검증해 사용자 정보를 확인 → 요청 처리 진행
            
            ** 세션 기반 → 서버가 사용자 상태를 직접 기억
            
            ** 토큰 기반 → 인증 정보를 클라이언트에 맡김
            
    - **JWT (JSON Web Token)**
        
        **: 서버에 따로 세션을 저장하지 않아도 인증이 가능한 자기 포함형 토큰**
        
        - 구조
            - xxxxx.yyyyy.zzzzz : 세 부분으로 나뉘며, 각각 . 으로 구분
            - Header(헤더) : 어떤 방식으로 토큰이 암호화되었는지 명시 (토큰 타입 포함) → 누구든 복호화 가능
            - Payload(페이로드) : 실제 데이터가 들어있는 부분 → 누구든 복호화 가능
            - Signature(서명) : 위 두 부분을 비밀키로 암호화하여 변조를 막는 부분 → 서버 측에서 관리하는 secreat key가 있어야 복호화 가능
            
    - **토큰 저장 위치**
        
        [1] 로컬 스토리지 / 세션 스토리지
        
        - 새로고침 하거나 브라우저를 닫았다 열어도 데이터 유지 → 로컬
        - 브라우저를 닫으면 자동으로 삭제 → 세션
        - 보안 취약 : XSS 공격(교차 스크립팅 공격)에 취약 → 악성 JS가 토큰을 읽어갈 수 있음
            - XSS : 웹사이트에 악성 스크립트를 삽입하는 공격 (ex. 화면 조작, 키보드 입력 훔치기 등)
        
        [2] 쿠키
        
        - 브라우저가 요청 시 자동으로 서버에 쿠키 포함 요청 전송
        - HttpOnly, Secure, SameSite 옵션을 설정하면 보안성 강화
        - HttpOnly 쿠키로 설정하면 자바스크립트에서 접근 불가능 → XSS 공격 방어
        - CSRF 공격에 취약 ⇒ 쿠키가 자동으로 전송되므로, 공격자가 사용자를 속여 악의적인 요청을 보내게 만들 수 있음
            - CSRF : 사용자의 권한을 이용해 공격자가 몰래 요청을 보내는 공격 (ex. 비밀번호 변경, 게시글 작성, 결제 등)
        
    - **클라이언트에서 토큰 관리 동작**
        1. 로그인 후 토큰 저장
            - ex. localStorage.setItem(”accessToken”, jwtToken);
        2. 요청 시 토큰 사용
            - Authorization 헤더에 토큰 추가
        3. 토큰 만료/갱신 관리
            - Access Token은 만료 시간이 짧음 → 만료되면 Refresh Token으로 갱신
                - Access Token : 클라이언트가 보호된 자원에 접근할 수 있는 권한 → 유효기간 제한
                - Refresh Token : 주로 장기적으로 사용되는 Access Token을 갱신하기 위해 사용 → 긴 유효기간
        4. 로그아웃 시 토큰 제거
    
- **헤더 작성 방식**
    - 세션 기반 인증 : 세션 ID를 쿠키 형태로 서버에 전송
        - 헤더 필드 : Cookie
        - 작성 형식 : Cookie: JSESSIONID=고유_세션_ID_값
        - 특징 : 브라우저가 쿠키를 저장하고 있다가, 요청 시 **자동으로 Cookie 헤더에 포함하여 서버로 전송** → 클라이언트 측 JS 코드가 직접 헤드를 조작할 필요 X
    - 토큰 기반 인증 : 토큰을 서버에 전송
        - 헤더 필드 : Authorization
        - 작성 형식 : Authorization: Bearer <토큰_값>
            - Bearer : 토큰의 종류
        - 특징 : 클라이언트 측 JS 코드가 저장소에서 토큰을 직접 읽어와 요청 시 Authorization 헤더에 **수동으로 삽입**
        
- **상황별 인증 방식 사용**
    
    
    | 상황 | 추천 인증 방식  | 이유 |
    | --- | --- | --- |
    | 전통 웹사이트 (학교 포털, 회사 내부 인트라넷, 홈페이지 등) | 세션 기반 | 서버에서 세션 관리가 쉬움, 브라우저 쿠키 자동 전송 |
    | 모바일 앱 / API 중심 (IOS/안드로이드 모바일 앱 등) | 토큰 기반 | 서버 stateless, 클라이언트에서 토큰 직접 관리 가능 |
    | 보안이 중요한 서비스 | 세션 기반 + HttpOnly 쿠키 / CSRF 토큰 | XSS 공격 위험 감소, CSRF 방어 가능 |

### 3. 캐시

- **캐시(Cache)**
    
    **: 자주 사용되는 데이터를 임시로 저장해두는 메모리 공간 또는 저장소**
    
    - 사용하는 이유
        1. 속도 향상
            - 원래 데이터 소스(DB, 서버) 접근보다 훨씬 빠름 → 자주 쓰는 데이터를 미리 가까운 곳에 두어, 반복 요청 시 시간을 절약함
        2. 서버 부하 감소
            - 동일 요청이 많을 때, 서버가 반복 처리하지 않아도 됨
            - 서버 리소스 절약 → 비용 절감
        3. 데이터 중복 방지
            - 같은 데이터를 여러 번 처리하거나 계산할 필요 없이, 한 번 계산된 결과를 캐시에 저장해 두고 재사용하여 컴퓨팅 자원 낭비를 막음