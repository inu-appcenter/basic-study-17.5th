# 3주차 
<details>
<summary><h3> 쿠키와 세션 </h3></summary>

## HTTP프로토콜의 특징
![alt text](image-7.png)
>참고) OSI 7계층 :네트워크 통신을 7개의 계층으로 나눈 이론  
응용:사용자와 상호작용 서비스 제공 (ex:http,smtp:이메일)  
전송:신뢰성 있는 데이터 전송 (TCP:포트번호 이용한 프로세스 간 통신)  
네트워크:목적지까지 패킷전달,라우팅 (IP,ARP:IP주소>MAC주소-물리주소)  
데이터 링크:mac주소 기반 전송,오류검출  
물리:비트단위의 신호 전송  
캡슐화 -> 역캡슐화

- HTTP 프로토콜이란? 
  - HyperText Transfer Protocol  
  - HyperText:단순한 텍스트를 넘어, 링크를 통해 다른 텍스트나 문서로 즉시 이동할 수 있는 비선형적인 텍스트
  - 클라이언트(웹 브라우저)-(stateless 웹) 서버 모델에서의 요청 - 응답 프로토콜(통신 규약)
  - IETF World Wide Web Consortium에서 공식적인 기술 표준으로 만듬  
  - OSI의 Application 응용 계층

- 요청 메세지
![alt text](image-9.png)
  - Start Line :HTTP 메소드:요청의 종류 (GET-데이터 조회,HEAD-본문 안 받기,POST-데이터 전송,PUT-데이터 전체 수정,DELETE-데이터 삭제,TRACE-서버한테 보낸 요청 메세지 반사 등) ,URL-요청 대상 리소스 주소 ,protocol 버전 
  - 요청 HTTP 헤더 :요청에 대한 추가 정보
    - Host :요청 호스트 이름과 포트번호
    - User-agent :클라이언트 프로그램 정보
    - Accept : 클라이언트가 처리 가능한 응답 형식
    - Referrer :이전 웹 페이지의 주소 
    - Cookie : 서버로부터 전송되었던 쿠키
  - Empty Line 및 Body:빈줄 및 메세지 본문(데이터)

- 응답 메세지
  - 응답 상태 코드
    - 1xx(정보 응답),2xx(요청 성공),3xx(서버가 다른 곳에 있을 때),4xx(클라이언트 오류),5xx(서버 오류)
  - 응답 HTTP 헤더:웹서버 종류,인증방식,Set-Cookie 등 응답에 대한 추가 정보
  - Empty Line 및 Body :메세지 본문,실제 데이터 (서버->클라이언트)

- 특징:비연결성(요청,응답 후 연결을 끊어서 클라이언트를 기억하지 못함),무상태성(HTTP 요청은 이전 요청과 독립적으로 처리->쿠키나 세션등을 이용해야 함) 

- 참고) stateless 서버 vs stateful 서버   
stateless 서버: 서버가 클라이언트의 이전 요청에 대한 정보를 기억하지 않음,확장성 뛰어남,설계 단순,관리 용이,쿠키 등이 필요   ex) 웹서버    
stateful 서버:서버가 서비스한 것에 대한 로그를 전부 저장하는 서버,사용자 맞춤 경험,확장 어려움,장애 복구 어려움 ex)은행업무,데이터베이스 

- 참고) HTTPS-HyperText Transfer Protocol Secure  : 데이터가 암호화되지 않아 정보가 인터넷 상에 노출될 수 있는 HTTP와 달리 전송 계층에서 SSL,TLS(SECURE SOCKET LAYER:인터넷에서 데이터를 안전하게 주고 받기 위한 암호화 프로토콜,TRANSPORT LAYER SECURITY:SSL IETF 표준문서)으로 암호화를 적용해 보안이 추가된 HTTP,속도는 HTTP보다 조금 느려질 수 있음,주소창에 자물쇠 아이콘 🔒이 HTTPS가 적용되었음을 의미

## 🍪쿠키🍪
- 정의 :클라이언트의 웹 브라우저에 저장되는 작은 데이터 조각,서버가 사용자의 상태정보(로그인 정보,사용자의 설정 등)를 저장하는 대신에 쿠키를 클라이언트의 브라우저에 저장

![alt text](image-10.png)

- 특징
  - 클라이언트에 저장,웹사이트 방문 시 서버가 쿠키를 받아온다
  - 민감한 정보를 저정하지 않음
  - 웹페이지를 개인화하거나 세션을 유지하는 데 사용
  - 서버가 응답메세지의 Set-Cookie 헤더를 통해 브라우저에 전달,브라우저가 요청 메세지의 Cookie 헤더에 담아 보냄
  - 키-값 쌍:세션ID=값 형태로 데이터 저장
  - 이름(세션ID),값,만료 기간(set-Cookie의 max-age=1000(1000초),expires=Sat,25-Dec-2021 04:39:22 GMT 로 지정),domain(도메인),path(경로),secure(보안 속성) 등 다양한 속성을 가질 수 있음
  - 지정한 쿠키가 모든 사이트에 들어가지 않게 도메인을 지정할 수 있음
  - 경로를 지정해서 그 하위 페이지만 쿠키 접근 가능하게 할 수 있음
  - secure 지정 시 https인 경우에만 전송,중간자 공격 방어
  - HttpOnly - xss(cross site scripting:브라우저 상에서 악성 스크립트 실행 유도)공격 방지,HTTP 전송에만 사용,자바 스크립트에서 접근 불가
  - SameSite -CSRF(CROSS-SITE REQUEST FORGERY:인증을 거친 사용자에게 사용자가 의도하지 않은 요청이 웹 사이트에 전달되도록 유도)공격 방지
  - 사용자 로그인 세션 관리 등에 자주 사용
  - 쿠키의 정보는 항상 서버에 전송이 되기 떄문에 네트워크 추가 트래픽 유발등의 단점을 가짐
  - Tracking :사용자 추적 (사용자의 웹사이트 방문 기록,검색 기록 등) 을 분석해서 맞춤 서비스 제공

- 참고) 자바스크립트의 접근을 막는 이유?  
자바스크립트는 강력한 프로그래밍 언어인 만큼 XSS공격에서와 같이 악용되면 위험할 수 있기 때문,XSS공격에서 피해자의 브라우저에서 악성 스크립트가 실행되면 실행해야 할 자바 스크립트로 인식해서 공격자의 서버 등으로 쿠키등을 훔쳐 세션에 접근하는 세션 하이재킹등이 일어날 수 있음

- 종류 
  - 세션 쿠키 :사용자가 브라우저를 닫으면 즉시 삭제되는 임시 쿠키,로그인 상태 유지,쇼핑몰 장바구니 등에 사용
  - 영구(영속) 쿠키 :만료 기간까지 유지되는 쿠키,브라우저를 닫았다가 다시 열어도 삭제되지 않음,자동 로그인,아이디 저장 같은 기능에 사용
  
 ## 세션,쿠키과 세션의 관계
 - 정의: 클라이언트와 서버의 상태를 유지하기 위해서 사용되는 데이터 조각,서버단에 사용자 정보를 저장

 - 특징 
   - 쿠키에는 보안상 민감한 정보를 저장하지 않음. 보안을 위해 서버의 세션 저장소에 민감한 정보를 저장하는데 각각의 세션 저장소에 접근하기 위한 식별표인 쿠키에 세션 ID를 저장
   - 클라이언트는 세션 ID만 보유
   - 서버는 세션 데이터를 메모리,파일,또는 외부 저장소에 저장 가능
   - 일정 시간 활동이 없으면 자동 만료

 - 세션 ID 흐름
  ![alt text](image-11.png)

 ## 쿠키와 세션의 차이점 
 - 쿠키는 브라우저 세션은 서버에서 관리하는 정보

 | |쿠키|세션|
 |---|---|---|
 |저장위치|사용자 클라이언트|서버|
 |만료시점|쿠키 저장 시 설정|브라우저 종료시 또는 세션의 유효기간 만료시|
 |요청 속도|세션보다 빠름|쿠키보다 느림|
 |보안|좋지 않음|쿠키보다 보안이 좋음|

</details>

<details>
<summary><h3> 세션 기반 인증 / 토큰 기반 인증 </h3></summary>

## 세션 기반의 인증 흐름
 ![alt text](image-11.png)
 - 사용자가 로그인 시 서버는 정보가 맞는지 확인하고 해당 사용자를 위한 세션 저장소를 서버에 생성,고유한 세션 ID를 생성해서 브라우저에 쿠키 형태로 전달
 - 세션ID를 서버가 저장 후, 요청이 들어올 때마다 세션 ID쿠키를 헤더에 담아 전달, ID를 보고 사용자 식별

## 토큰 기반의 인증 흐름
![alt text](image-12.png)
- 사용자가 로그인 시 서버가 인증에 성공하면 암호화된 토큰을 발급,HTTP 헤더를 통해 클라이언트의 쿠키,로컬 스토리지등에 저장
- 클라이언트는 요청마다 토큰을 HTTP Authorization 헤더에 포함해서 요청,서버는 토큰이 위조되지 않았는지 확인 후 회원의 ID를 읽어 데이터베이스를 조회하여 처리

## JWT의 구조
![alt text](image-13.png)
- JWT(JSON Web Token)란? - 토큰 인증에서 가장 많이 사용되는 방식
- 민감 정보저장 하는 것이 아닌 신분증 역할
- 서명으로 신뢰성 보장 
- 점(.) 으로 구분되는 세 부분으로 이루어진 문자열
- Header 헤더, Payload 내용, Signature 서명으로 구분
- 헤더 - 사용된 알고리즘,토큰타입
- 페이로드 - 사용자ID,권한,토큰 만료 시간 등(암호화 되지 않고 인코딩만 되므로 민감한 정보 저장 x)
- 서명 - 서버의 Secret 키로 서명된 암호화
---
### JWT가 탈취된다면?
- 세션의 경우 인증 정보가 서버에 저장되어 관리되기 때문에 보안에 유리,세션 ID가 탈취되어도 해당 세션을 무효처리 가능
- 토큰의 경우 모든 인증정보를 토큰이 지니고 있고 Payload가 별도로 암호화되지 않기 때문에 토큰이 해커에게 탈취되면 해당 토큰이 만료되기 전까지 피해를 입을 수 있다
이를 해결하기 위해 여러 방법을 도입
- 엑세스 토큰: 유효기간 짧음 (15분) ,새로운 API 요청 등 실질적인 인증에 사용
- 리프레쉬 토큰: 유효기간 김,새로운 엑세스 토큰을 발급받는 데에 사용,비교적 안전한 곳에 저장
- 로그인 시 짧은 수명의 엑세스 토큰과 긴 수명의 리프레스 토큰을 발급받고 API요청시 엑세스 토큰만 사용, 엑세스 토큰이 만료되면 리프레쉬 토큰을 서버에 보내 새로운 엑세스 토큰 발급 
- 서버에서 사용자가 비밀번호를 바꾸거나 했을 때 토큰 블랙리스트 등을 만들어 추가,매 요청 블랙리스트를 확인해야 하므로 서버에 부하 가능

## 토큰 저장 위치 (로컬/세션/쿠키)
- 브라우저 메모리(자바스크립트 변수) -자바스크립트 변수에 데이터를 저장,휘발성이기 때문에 변수에 토큰이 잠시 할당되어 있는 순간 해커가 공격을 실행해야지만 유효,엑세스 토큰 등
- HttpOnly 쿠키 -JS 접근 불가 -리프레쉬 토큰 등 저장
- Local Storage - 브라우저 내에서 데이터 영구저장하기 위해 만들어짐,클라이언트가 자바 스크립트로만 접근 가능,xss공격에 취약 
- Session Storage -브라우저 내에서 데이터 임시저장하기 위해 만들어짐,브라우저 닫으면 데이터 삭제됨,자바스크립트로만 접근 가능,xss공격에 취약
- local과 session이 보안에 약해서 추천이 안됨에도 사용이 되는 것은 구현이 간단하고,UX가 좋음(로그인 상태가 그대로 유지),XSS방어가 확실한 상황
- 메모리,HttpOnly 쿠키는 보안은 좋지만 편의성과 UX가 불편하므로 높은 보안이 필요한 서비스에서 사용

## 각 인증 방식에서 헤더 작성 방식

- 세션 기반의 인증
  - 브라우저가 자동으로 COOKIE헤더에 세션 ID를 담아 서버로 보냄
  > GET /user/mypage HTTP/1.1  
Host: www.example.com  
Cookie: JSESSIONID=A5F4E2B1C8D9E0F3A2B1C4D8E7F6A0B9
- 토큰 기반의 인증
  - 클라이언트가 수동으로 Authorization 헤더에 토큰을 담아 서버로 보냄
  >GET /api/user/mypage HTTP/1.1  
Host: api.example.com  
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjMifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
  - Bearer는 전달하는 방식(인증 스킴),가장 널리 사용,뒤에 값이 jwt토큰값 
  - 실제로는 자바스크립트 코드를 작성하여 과정을 자동화한다.
 
## 클라이언트에서 토큰은 어떻게 관리될까
- 로그인 성공 시 두가지 토큰 발급,각각 클라이언트의 특정 위치에 저장 
- 엑세스 토큰이 만료되면 서버는 특정 에러를 응답으로 보냄,클라이언트가 특정 에러를 감지하면 리프레시 토큰을 이용해 새로운 엑세스 토큰을 요청,클라이언트는 새로운 엑세스 토큰을 메모리에 업데이트,API 요청 새로운 토큰으로 다시 보냄,리프레시 토큰이 만료됐다면 재발급을 거부하고 사용자를 로그아웃 처리
- 사용자가 로그아웃 시 메모리에 있는 엑세스 토큰과 쿠키에 있는 리프레시 토큰을 모두 삭제

</details>

<details>
<summary><h3> 실무에서는 어떤 인증 방식을 사용할까 ? </h3></summary>

- 세션기반 인증에서는 서버가 상태를 메모리/DB에 저장,서버의 부담 증가(stateful)
- 토큰기반 인증에서는 상태 저장 X,토큰 자체로 인증
- 세션기반 인증에서는 서버에서 세션 제거 가능
- 토큰기반 인증에서는 탈취시 취약,Payload 디코딩 가능
- 세션기반 인증에서는 서버 간 세션 동기화 필요
- 토큰기반 인증에서는 토큰만 있으면 어느 서버에서도 처리 가능
- 단일 서버,간단한 서비스 ->세션&쿠키
- 대규모 트래픽,마이크로서비스 아키텍처(MSA-기능별로 서버를 잘게 쪼개는 방식) -> JWT
- 민감 정보 다수 포함 -> 세션
- 외부 서비스 연동 -> JWT 

웹 페이지 중심 시스템(서버 렌더링 웹사이트-한 서버에서 모든 페이지를 직접 그려서 보내주는 구조의 웹사이트) -> 세션 + 쿠키 조합 (ex. JSP, Spring MVC, Ruby on Rails 등)

SPA-웹사이트가 하나의 파일처럼 동작하는 방식(React, Vue 등) + API 서버 ,모바일 앱과 연동하는 경우-> 토큰 기반(모바일 앱은 쿠키 관리 까다롭고 웹,앱에서 토큰이 더 쉽게 주고 받을 수 있기 때문에)

보안 강화가 필요할 땐 -> JWT + HttpOnly 쿠키 + Refresh Token 분리 저장

</details>

<details>
<summary><h3> 캐시 </h3></summary>

- 캐시(Cache) : 데이터를 저장하여 나중에 해당 데이터에 대한 요청을 더 빠르게 처리할 수 있도록 하는 임시 저장소(하드웨어,소프트웨어)
- 하드웨어에서 다시 사용될 가능성이 있는 데이터 임시 저장하는 메모리 블록으로 구현(CPU내부등에 설치,저장 공간 등에 따라 여러 종류가 있음)
- 캐시는 메모리여서 DB와 같은 하드디스크를 읽는 속도보다 빠름 -> 서버 부하 감소,비용 절감
- 동작 과정
    - 클라이언트가 서버에 데이터 요청
    - 서버는 캐시 확인,해당 데이터가 없으면 Cache miss
    - DB에 가서 데이터 가져옴
    - 데이터 클라이언트에게 전달 후 캐시에 복사본 저장
    - 클라이언트가 동일한 데이터 요청 시 캐시에 데이터가 있으면 Cache hit
    - 캐시에서 바로 데이터를 꺼내 클라이언트에게 전달
- 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)== 캐시 적중률
- 캐시 적중률을 높이기 위해 참조 지역성의 원리를 사용(시간 지역성-CPU는 최근에 접근했던 메모리 공간에 다시 접근하는 경향이 있다,공간 지역성-CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다)
--- 
- 브라우저 캐시 : 사용자의 개인 컴퓨터에 데이터를 저장하는 방식
- CDN 캐시 : 전 세계 여러 지역에 분산된 서버에 콘텐츠를 미리 복사해주는 기술
- 서버 캐시: 원본 데이터가 있는 웹 서버 자체에서 자주 요청되는 데이터를 메모리(RAM) 등 초고속 공간에 임시 저장하는 방식
</details>


