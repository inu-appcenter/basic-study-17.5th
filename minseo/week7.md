# 앱센터 7주차 
## 데이터베이스란? 

### 데이터베이스의 정의와 필요성
### 정의 
![](https://velog.velcdn.com/images/paul04030/post/aa2bc2d3-b226-4077-a788-e6c416030f19/image.png)

### **DataBase / DB**:


- 체계적인 데이터 컬렉션을 저장,관리 및 보호하기 위한 디지털 저장소(**데이터의 집합**)
- 일반적으로 컴퓨터 시스템에 전자적으로 저장(**저장 데이터**)되는 체계적인(구조화된) 데이터 모음(숫자,단어,이미지,비디오,파일 등)
- 여러 사람에 의해 공유되거나 사용될 수 있다(**공유 데이터**).
- **통합 데이터**: 최소 중복,통제 가능한 중복만 허용하는 데이터
- **운영 데이터**: 필요한 데이터를 저장 
- 다양한 방식으로 데이터를 저장
- **DBMS**에 의해 제어
- 데이터에 쉽게 접근,관리,수정 등을 하기 위해 데이터 작성 및 쿼리에 **(SQL)**사용
- 데이터베이스는 시스템으로  데이터가 저장되는 **물리적 하드웨어**와 데이터에 대한 엑세스를 구성하고 제어하는 **소프트웨어**로 구성


### 데이터 베이스 사용예시
카카오톡 메세지
인스타그램에 등록한 사진
버스/지하철에서 찍은 교통카드
사기 탐지
문서 관리
게임 및 엔터테이먼트 등

카카오톡 데이터베이스 예시(가상의 예시) > 여러 종류의 데이터베이스를 조합
1. 유저,채팅방 정보 등 >관계형 DB
2. 실제 메세지 본문 > NoSQL DB (수평적으로 확장해야 하므로)
3. 사진,동영상,파일 등 > 자체 스토리지(오브젝트 스토리지)
4. 검색용 데이터 > 검색 엔진(색인 사용)


**참고**) 데이터베이스 vs 스프레드 시트 

- 데이터 저장 및 조작 방법
     - 데이터베이스는 복잡한 로직,언어 사용해 조작
     - 스프레드 시트는 간단한 데이터 조작
- 데이터에 엑세스 할 수 있는 사람
	 -  스프레드 시트는 한명 혹은 적은 사용자 
	 -  데이터베이스는 여러 사용자가 동시에
- 저장할 수 있는 데이터 양
 	- 데이터 베이스가 훨씬 방대한 양의 데이터 저장

### 데이터베이스 필요성

- 1950~ 60년대 초에 첫 등장 (본래는 군대용-데이터의 기지라는 뜻)
- 방대한 데이터를 저장,관리 하기위해 데이터베이스도 함께 발전
- 데이터 베이스는 IT서비스를 만드는데 필요한 다양한 정보(회원정보,서비스 이용 등), 사용자 정보들을 기록 가능
- 기업은 고객 걸 및 제품 재고에서 내부 프로세스 및 독점 연구에 이르기까지 모든 것에 대해 종종 페타바이트 또는 수조 비트 단위로 측정되는 대량의 데이터를 소유 -> 일관된 데이터 아키텍처로 구성 필요(효율적 확장)
- 데이터의 보안,무결성 보장
- 데이터 분석(데이터 베이스를 사용하여 추세 패턴 등 분석 가능)

**참고**) 2-tier , 3-tier 아키텍처
tier (계층 :컴포넌트들의 물리적인 분리 > 서로 다른 하드웨어에서 실행된다)
-> 소프트웨어(데이터베이스)를 사용하는 시스템을 어떻게 구성하는지에 대한 구조 설계 방식


최근 대부분의 웹 개발은 3계층으로 구성 (간단한 웹은 2계층도)
![](https://velog.velcdn.com/images/paul04030/post/8f1262b5-0876-4ce5-9220-a0c6aeddc5fa/image.png)

2tier 
- 웹서버가 DB에 바로 연결
- 트래픽이 많지 않은 경우 자주 사용
- 서버 역할이 WEB서버 , DB서버 두가지
- 문제점: 보안(DB직접 다룸) ,부하(여러 명이 동시 사용 시), 유지보수(DB내용 바뀌면 클라이언트 프로그램 일일이 수정) 등등

![](https://velog.velcdn.com/images/paul04030/post/6cc76687-4049-45b4-a2d2-a258123dd274/image.png)

3tier 
- 클라이언트(Web서버)-애플리케이션 서버(Was서버)-데이터서버(DB서버)
- Web서버와 Was서버 분리
- Web서버 - 웹 브라우저 클라이언트로부터 HTTP요청을 받아 정적 컨텐츠 제공(.html,.jpeg,.css > 고정된 파일) > 서버 부담 완화
- Was서버 - DB조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 서버 > 효율적 자원 사용
- 보안(중간에 WAS) ,확장성(이용 인원이 많아지면 애플리케이션 서버만 확장하면 됨),유지보수(DB내용 바뀌면 애플리케이션 서버에 공지)


###  데이터베이스 주요 특징
![](https://velog.velcdn.com/images/paul04030/post/1c0521bc-7c21-40c2-a45f-d9b726090652/image.png)

**무결성** - 데이터 일관성을 유지하기 위한 기본 규칙 혹은 조건 존재
**가용성** - 필요할 때 언제든 사용 가능
**기밀성** - 특정 조직(인가된 사람)만 데이터베이스에 접근 가능
**실시간 접근성** - 데이터 베이스에 저장된 데이터에 대한 빠른 접근(읽기,쓰기)이 가능
**지속적인 변화** - 항상 최신의 데이터를 유지
![](https://velog.velcdn.com/images/paul04030/post/78567444-8d88-4704-bb04-1c55d308923d/image.png)
**동시 공유** - 여러 사용자가 동시에 데이터베이스를 공유하고 이용 가능
**내용에 대한 참조** - 데이터를 참조할 때 데이터의 내용을 기반으로 참조 >유연성(데이터 구조,형식 의존 X) ,검색 효율성 (검색 알고리즘,쿼리 기능) ,자동화(자동으로 적절한 데이터 구조에 맞게 분류,정리)
**내용에 의한 참조** - 사용자가 요구하는 데이터 내용으로 데이터 참조
**데이터 논리적 독립성** - 전체적인 논리적 구조(스키마)가 변경되어도 기존에 작성된 프로그램은 영향을 받지 않음
**데이터 물리적 독립성** - 데이터가 실제로 저장되는 물리적인 방식이 변경되도 응용 프로그램은 영향을 받지않음(SQL 쿼리는 영향X)
**효율적인 확장** :데이터베이스 애플리케이션은 수백만, 수십억 개 등으로 확장하여 대량의 데이터를 관리 가능
**데이터 보안**:데이터베이스는 모든 데이터와 관련된 개인정보 보호 및 규정 준수 요구 사항을 지원

### 데이터베이스의 장단점 
**데이터베이스 장점**
데이터 중복 최소화
데이터 공유
일관성, 무결성, 보안성 유지
최신의 데이터 유지
데이터의 표준화 가능
데이터의 논리적, 물리적 독립성
용이한 데이터 접근
데이터 저장 공간 절약

**데이터베이스 단점**
데이터베이스 전문가 필요
많은 비용 부담
데이터 백업과 복구가 어려움
시스템의 복잡함

### 데이터베이스 스키마
- 데이터베이스 내에서 데이터가 구성되는 방식을 기술적이고 논리적으로 정의(설계도) 

- 관계형 데이터베이스 스키마는 테이블 이름, 필드, 데이터 유형 및 이러한 항목 간의 관계와 같은 것들을 정의

- 스키마는 시각적 차트를 통해 표현되거나, SQL 문 또는 기타 프로그래밍 언어로 작성되거나, 다른 방식으로 정의

- 모든 관계형 데이터베이스 시스템에는 스키마가 존재
- 비관계형 데이터베이스에는 스키마가 있거나 없다.

### 데이터베이스의 종류
크게  **관계형(RDB) / 비관계형 (NoSQL)** 으로 나눈다. 

![](https://velog.velcdn.com/images/paul04030/post/634d7710-8b57-4eef-89e2-f0fc5dc1583d/image.png)

### **관계형 데이터베이스 ( = RDB)**
- 데이터를** 행과 열**이 있는 **표(릴레이션-스키마,인스턴스(실제 데이터값))** 형태로 구성하여 논리적 관계를 기반으로 데이터를 저장하고 조회하는 **데이터베이스 구조**
- **정규화**를 통해 **데이터 중복 최소화**
- 복잡한 **조인 연산**을 통해 다양한 데이터 조회 가능
- **스키마 엄격**
- 강력한 **ACID 트랜잭션** 지원
- 금융 시스템,ERP(기업의 모든 자원을 통합적으로 관리하는 시스템),CRM(고객과의 관계를 관리하는 시스템) 등에 사용
- 데이터 정확성이 중요한 업부 시스템에 널리 사용
- SQL사용 (Structured Query Language)
- 수직 확장 중심
- 데이터 간 관계가 명확,정형 데이터(구조가 미리 정해져있음,형태가 일정)가 많은 경우
- MySQL, PostgreSQL ,Oracle

![](https://velog.velcdn.com/images/paul04030/post/f98bb559-f7bc-43b4-b855-5d3d93dba5e4/image.png)
**관계형 데이터베이스 구조**
**릴레이션(테이블)** - 
- 한 릴레이션에 포함된 튜플들은 모두 상이
- 한 릴레이션에서 튜플 사이에는 순서x
- 튜플들의 삽입,삭제로 릴레이션은 시간에 따라 변함
- 릴레이션 스키마속성들 간의 순서는 중요하지 않음
- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 구성하는 값은 동일한 값이 있을 수 있음
- 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키로 설정
- 속성은 더 이상 쪼갤 수 없는 원자 값만을 저장

**스키마** 

**인스턴스** - 실제 데이터

**튜플** -릴레이션의 행,속성의 모임

**속성** -릴레이션의 열,데이터베이스를 구성하는 가장 작은 논리적 단위,개체의 특성을 기술

**도메인** -하나의 속성이 취할 수 있는 같은 타입의 원자값들의 집합(속성들이 취할 수 있는 제약조건,데이터 유형,길이 등이 정의)

**카디널리티** - 튜플의 수(기수,대응수라고도 불림)

**디그리** - 속성의 수(차수 라고도 불림)

**null value** - 알 수 없거나 존재하지 않음을 나타내는 특수 값

### **키** 
- 튜플을 고유하게 식별하기 위해 사용되는 용어

**슈퍼키(Superkey)**
![](https://velog.velcdn.com/images/paul04030/post/869eec45-7b53-4d3d-9a1e-18ac962a7d37/image.png)

- **하나 이상의 속성 집합**으로, 튜플을 **고유하게 식별 가능**
ex) instructor(ID, name, dept_name, salary)에서 ID는 고유하여 슈퍼키가 될 수있지만, name은 동일한 이름이 존재할 수 있기 때문에 슈퍼키가 아님. 하지만 {ID, name} 집합은 ID만으로 충분히 슈퍼키가 될 수 있기 때문에 {ID, name} 집합은 슈퍼키가 될 수 있다.

**후보키(Candidate Key)**
![](https://velog.velcdn.com/images/paul04030/post/d6f3c72c-72a7-4f82-9923-274400832bdb/image.png)

**최소 슈퍼키**로, **튜플을 고유하게 식별**하는 데** 필요한 속성만 존재**
ex) {ID, name} 집합은 슈퍼키, ID만으로 튜플을 식별할 수 있으면 {ID, name} 집합은 후보키가 아님.

**기본키(Primary Key)**
![](https://velog.velcdn.com/images/paul04030/post/d8934ebe-2909-469b-a39b-6ec2932280e6/image.png)

튜플을 고유하게 식별하기 위해 **선택한 후보 키 중 하나.** >>**단일 기본키**
테이블 마다 하나지만 두 개 이상 컬럼을 묶어서 구성 가능(**복합 기본키**)
속성 값이 **절대 변경되지 않거나 매우 드물게 변경되도록 선택**해야 한다.
기본키 제약 조건(속성값이 유일해야하고, NULL이 아니여야한다.)

**대체 키(Alternate Key)**
![](https://velog.velcdn.com/images/paul04030/post/7328bb5b-7e0c-450b-90f0-0f5e9007c6f6/image.png)

하나를 기본키로 지정하고 남은 후보키

**외래키(Foreign Key)**
![](https://velog.velcdn.com/images/paul04030/post/cdbac05e-111d-461a-99b1-5ad3e234d3f6/image.png)

**다른 릴레이션의 기본 키를 참조**하여 **릴레이션 간에 링크 생성**
참조됨>부모테이블 , 참조함>자식 테이블

위의 예시에서는 학생>부모테이블 , 수강>자식테이블
학생 테이블의 학번:기본키,참조되는 키
수강 테이블의 학번:참조하는 키,외래키

ex) instructor의 dept_name은 department(dept_name, building, budget)의 기본키 dept_name을 참조하는 경우 외래키가 될 수 있다. 이렇게 되면 instructor의 dept_name은 실존 하는 department에 할당

**외래키 제약 조건**(한 릴레이션의 특정 속성이 다른 릴레이션의 기본 키 또는 고유 키를 참조하도록 강제하는 제약 조건) >> 한쪽 키의 데이터를 조작하기 위해서 참조하거나 참조당하는 키의 데이터도 함께 처리 >> 두 테이블 간의 관계를 유지하고 데이터의 일관성을 보장



### **비관계형 데이터베이스 ( = NoSQL) NoSQL 데이터베이스**
- 관계형 데이터베이스구조가 아닌 데이터베이스 구조
- RDB보다 자유로운 구조
- 유연한 스키마
- SQL이 아닌 쿼리언어 또는 API사용
- BASE속성 > 일관성보다 가용성
- 수평 확장 용이
- 대규모 데이터,비정형 데이터(형태 일정X) 등을 다룸

![](https://velog.velcdn.com/images/paul04030/post/5e1ffca1-277d-4838-8210-f943ab9ffd2a/image.png)

**key-value 데이터베이스** 
- key : value 형식으로 데이터 저장 
- 스키마(데이터가 어떤 구조로 저장될지)가 없어 자유로운 데이터 저장 가능,단순한 구조로 빠른 읽기 쓰기 가능 
- 서브용 DB로 자주 사용
- redis,Amazon DynamoDB

![](https://velog.velcdn.com/images/paul04030/post/a4cf4776-c0e1-4497-af3e-d80880d21c07/image.png)

**document 데이터베이스(문서/JSON 데이터베이스)** 
- collection > document >json 형태로 정보 저장 
- 입출력 잦을 때 사용 
- 스키마가 유연하여 다양한 구조의 데이터 저장
- 분산처리에 적합,수평적 확장에 용이
- 콘텐츠 관리 시스템,블로그 플랫폼 등에 사용
- MongoDB

**탐색 데이터베이스** ->거의 사용 X
- 연결된 레코드 집합에 데이터를 저장
   - **계층적 데이터베이스** - 상위 레코드와 하위 레코드로 구성된 트리 구조로 데이터 정렬
   - **네트워크 데이터베이스** - 하위 레코드가 여러 상위 레코드에 연결될 수 있음.일반적으로 포인터를 사용하여 원하는 데이터에 도달 
   
**검색용 인덱스 보관 데이터베이스**
- 빠른 검색은 위해 데이터의 색인(인덱스) 정보를 저장,관리하는 DB

**자율 운영 데이터베이스**
- AI가 자동으로 관리,최적화,백업을 수행하는 DB

**오픈 소스 데이터베이스**
- 소스코드가 공개되어 자유롭게 수정,배포 가능한 DB

**분산 데이터베이스**
- 데이터를 여러 서버에 나눠 저장해 확장성과 복구 능력을 높인 DB

**객체 지향 데이터베이스** 
- 객체 지향 프로그래밍 언어에서 데이터를 객체로 저장

**벡터 데이터베이스**
- 벡터(숫자 배열로 정보 저장) 
- 자연어 처리 및 AI분야에서 사용

### 현대 데이터베이스
클라우드에 방대한 데이터를 저장,기계 학습 및 기타 데이터 분석을 위한 고급 소프트웨어 인터페이스를 제공 가능

**클라우드 데이터베이스**
- 일반적으로 클라우드 컴퓨팅 플랫폼에서 실행(데이터를 AWS,Google Cloud 같은 클라우드 서비스 제공자의 서버에 저장)
- 사용자는 클라우드에서 데이터베이스를 독립적으로 실행하거나 클라우드 데이터베이스 공급자로부터 액세스 권한을 구매 가능.
- 하나의 클라우드 서비스 안에서 SQL 및 NoSQL 둘 다 지원 ( 주문 ,결제 > SQL / 로그,피드,알림,채팅 >NoSQL)

**그래프 데이터베이스**
![](https://velog.velcdn.com/images/paul04030/post/33da73f6-ed4d-4e73-82ea-ad02b62fe906/image.png)

- 관계를 저장하고 탐색
- 노드와 엣지로 구성
- 노드는 데이터 객체를 저장, 엣지는 객체 간의 관계를 저장
- 관계 탐색이 효율적
- 소셜 네트워크 분석,추천 엔진 구현
- Neo4j

**인 메모리 데이터베이스**
![](https://velog.velcdn.com/images/paul04030/post/f7672c03-b4d0-4203-885d-caf03cfb6f7e/image.png)

- 대부분의 데이터베이스는 외부 저장 장치(디스크 등)에 저장
- 인 메모리 데이터베이스는 컴퓨터의 내부 메모리에 데이터를 업로드하여 사용
- 일반적으로 컴퓨터 데이터 스토리지(디스크 등)로도 백업
- 인 메모리 데이터베이스는 디스크 데이터베이스보다 빠른 속도
- 휘발성(전원이 꺼지면 날아감)등의 문제가 존재 >주기적으로 디스크에 백업
- 통신 네트워크 장비와 같이 응답 시간이 중요한 곳에서 자주 사용

### ACID규칙
**원자성 (Atomicity)** - 트랜잭션은 하나의 단위로 취급(모든 작업이 성공하거나 성공하지 않거나)
**일관성 (Consistency)** - 트랜잭션이 실행된 전후에 데이터베이스의 모든 규칙이 올바르게 유지(송금 시 총 잔액 변경 x)
**격리성,고립성 (Isolation)** - 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 다른 트랜잭션의 영향 x
**내구성,영속성(Durability)** - 트랜잭션이 성공하면 그 변경 사항은 전원이 꺼져도 유지

**병행제어란?** - 동시에 데이터베이스를 조작할 때 ,데이터의 일관성과 정확성을 유지하기 위한 제어 기술 -> 락(lock) 이나 스케줄링을 통해서

### DBMS의 개념과 역할 
![](https://velog.velcdn.com/images/paul04030/post/384c6c04-6061-49c9-867b-e2194b59a925/image.png)

**DataBase Management System  **
- 데이터 베이스를 관리하고 운영하는 **소프트웨어**  >여러 명의 사용자나 응용 프로그램과 공유,**동시에 접근**
- 응용 프로그램이 DB에 접근할 수 있게 **인터페이스 제공**
- **스키마를 참조해 사용자의 명령**을 수행
- **MySQL,Oracle,MongoDB,Neo4j 등이 존재**

- **정의(데이터의 구조,형식등을 명세,저장),구축,조작,공유(동시 접근 관리),보호(시스템 보호),유지보수,트랜잭션(여러 작업을 하나의 논리적 단위로 실행해 일관성,안전성 보장),무결성(데이터의 정확성과 일관성 유지),백업,복구,보안-권한(접근 권한 설정),중복 최소화-접근성(중복 저장 줄임) 등의 역할 제공**

- **DBMS언어 사용**(그 중 대표적인 언어가 SQL-관계형 DBMS에서)
**DBMS언어의 종류**

- DDL 테이블,DB관리
    -CREATE : 데이터베이스 생성
    -ALTER : 데이터 베이스의 구조 변경
    -DROP : 데이터베이스 삭제 (데이터와 구조 모두 삭제)
    -RENAME : 데이터베이스 이름 변경
    -COMMENT : 데이터에 주석등을 추가
    
- DQL 데이터 조회
	-SELECT : 데이터 검색하는데 사용한다.
- DML 데이터 관리
    -SELECT : 데이터 조회
    -INSERT : 데이터 삽입
    -UPDATE : 데이터 수정
    -DELETE : 데이터 삭제
- DCL 접속권한
	-GRANT : 특정 데이터베이스 사용자에게 특정 작업에 대한 수행 권한 부여
	-REVOKE : 특정 데이터 베이스 사용자에게 특정 작업에 대한 권한을 없애거나 회수
- TCL 트랜잭션 제어
	-COMMIT	: 트랜잭션의 작업이 정상적으로 완료되었음을 알림
	-ROLLBACK : 데이터베이스를 마지막 COMMIT 된 시점의 상태로 복원

    
---

## SQL의 개념 및 기본 문법

### SQL 개념
![](https://velog.velcdn.com/images/paul04030/post/f614772b-1203-4989-8acc-d40c03c4f7bb/image.png)

**Structured Query Language**
- DBMS 언어의 일종
- 관계형 데이터베이스에 정보를 저장하고 처리하기 위한 프로그래밍 언어
- 1970년대 IBM에서 최초 개발
- 표준 : ANSI SQL
- 많은 곳에서 널리 사용되는 쿼리 언어 


### 기본 문법 (+ 예시 쿼리문)
### **기본 구조**
```sql
<명령어> <대상> <조건>
```

**명령어** : 수행할 작업 지정 EX) SELECT,INSERT
**대상** : 작업을 수행할 데이터베이스 객체(테이블 등)를 지정
**조건** : 특정 조건을 통해 데이터를 필터링하거나 조작 (WHERE절을 통해 표현)

### CREATE - 데이터 베이스 생성
```sql
create database testdelete
```
### USE - 스키마(데이터베이스) 선택
```sql
USE market_db;
```
- USE문을 사용하여 SQL을 사용할 스키마 지정

### 대소문자 구분
- SQL키워드는 대소문자를 구분하지 않음,하지만 대문자로 작성하는 것이 일반적
- 식별자는 대소문자를 구분하므로 혼란을 피하기 위해 일관된 방식으로 사용

### 주석 사용법
1. 단일 행 주석 (-- 기호 사용)
```sql
SELECT first_name, last_name  -- 직원의 이름과 성을 선택합니다
FROM employees;                -- employees 테이블에서 조회 
```
- SQL 쿼리 실행에 영향을 미치지 않음
2. 다중 행 주석 (/*  */)

```sql
/* 베이직 화이팅~ */
SELECT first_name, last_name
FROM employees;   
```

**Join 연산이란?**
![](https://velog.velcdn.com/images/paul04030/post/118d164c-9e3e-4786-90ed-617777baac8a/image.png)

- 두 개 이상의 테이블을 공통된 값을 기준으로 묶어서 하나의 결과로 합치는 것(데이터를 뽑아내는 연산,조회!)
**INNER JOIN(**일치하는 행이 있는 부분만 표기하는 조인)
- 조인하는 테이블의 ON 절의 조건이 일치하는 결과만 출력
```sql
select u.userid, name 
from usertbl as u inner join buytbl as b 
on u.userid=b.userid 
where u.userid="111"

select u.userid, name 
from usertbl u, buytbl b 
where u.userid=b.userid and u.userid="111"

```

**OUTER JOIN**(조건에 만족하지 않는 행들도 결과로 출력하기 위한 조인방법) -LEFT,RIGHT,FULL
**LEFT JOIN** - 대부분 사용,첫 번쨰 테이블을 기준으로 두 번째 테이블을 조합하는 JOIN

![](https://velog.velcdn.com/images/paul04030/post/90b4d0e4-8ef3-4efb-b669-803bc4ce3659/image.png)
```sql
SELECT STUDENT.NAME, PROFESSOR.NAME 
FROM STUDENT LEFT OUTER JOIN PROFESSOR 
ON STUDENT.PID = PROFESSOR.ID 
WHERE GRADE = 1


```
**RIGHT JOIN** - 두 번째 테이블 기준으로 첫 번째 테이블 조합

**FULL JOIN**
![](https://velog.velcdn.com/images/paul04030/post/5b48a671-0dc0-4d7e-977c-f18d7af978a2/image.png)
```sql
select * 
from topic FULL OUTER JOIN autor 
on topic.auther_id = authoer.id
```
**EXCLUSIVE LEFT JOIN**
![](https://velog.velcdn.com/images/paul04030/post/c99bcd11-b2bd-47f9-abb1-2fb7d8cd1138/image.png)

- 둘중 한가지 테이블에만 있는 데이터를 가져온다.
```sql
SELECT * 
FROM table1 A LEFT JOIN table2 B
ON A.ID_SEQ = B.ID_SEQ 
WHERE B.ID_SEQ IS NULL
```
**FROM**: 데이터베이스에서 데이터를 가져올 테이블을 지정. 이 단계에서 조인(Join) 연산이 수행

**WHERE**: FROM 절에서 선택된 데이터에 대해 조건을 적용하여 필터링. 이 단계에서 조건을 만족하는 데이터만 선택
```sql
SELECT * FROM member 
	WHERE mem_number >= 5;
```
- 관계,논리 연산자도 사용 가능 
- AND(&&)>OR(||) 우선순위

```sql
SELECT * FROM member 
	WHERE height between 160 and 165;
```
- between 연산자를 사용하여 범위 조회 가능
```sql
SELECT * FROM member 
	WHERE addr IN('경기', '전남', '경남');
```
- IN()을 사용하여 특정 값이 포함된 데이터 조회 가능 
```sql
-- mem_name 컬럼 값이 '블'로 시작하는 4글자 글자 데이터 조회
SELECT * FROM member WHERE mem_name LIKE '블___';

-- mem_name 컬럼 값이 '블'로 시작하는 모든 데이터 조회
SELECT * FROM member WHERE mem_name LIKE '블%';

-- mem_name 컬럼 값에 '블'이 들어가는 모든 데이터 조회
SELECT * FROM member WHERE mem_name LIKE '%블%';
```
- LIKE를 사용하여 문자열의 일부 글자 검색
- _:한 글자만 매치, %:몇 글자든 매치


**GROUP BY**: 데이터를 그룹화. 같은 값을 가진 데이터들을 하나의 그룹으로 묶어 집계 함수(예: COUNT, SUM 등)를 사용 가능

**HAVING**: GROUP BY 절에서 생성된 그룹에 대해 조건을 적용. 이 단계에서 그룹화된 데이터 중에서 조건을 만족하는 그룹만 선택.

**ORDER BY**: 최종 결과를 정렬. 지정된 열을 기준으로 오름차순 또는 내림차순으로 정렬.

**LIMIT(또는 ROWNUM)**: 최종 결과에서 반환할 행의 수를 제한.
```sql
SELECT * FROM member
	LIMIT 3;    		-- 상위 3건만 조회

SELECT * FROM member
	LIMIT 3, 2; 		-- 3번째 데이터부터 2건만 조회
	LIMIT 2 OFFSET 3; 	-- 위와 동일
```

### **SELECT** - **데이터를 읽어오는 구문**

```sql
SELECT 열_이름1,열_이름2
	FROM table이름 
    WHERE 조건식;
```
- 가장 빈번하게 사용되는 구문
- 테이블에서 지정된 값 가져오는 구문
```sql
SELECT first_name, salary
FROM employees
WHERE department_id = 30;
```
- employees 테이블에서 직원의 이름과 급여를 조회,조건은 부서 id = 30

```sql
SELECT *
FROM employees;
```
- *을 사용하면 모든 열 조회

### **INSERT ** - 데이터베이스에 새로운 데이터를 추가할 때 사용

```sql
INSERT INTO 테이블명 (열1, 열2)
	VALUES (값1, 값2);
```
- 기본 형식
```sql
INSERT INTO employees (employee_id, first_name, last_name, salary, department_id)
VALUES (1001, 'John', 'Doe', 3000, 30);
```
- employees 테이블에 새로운 직원 정보를 추가
- id는 1001,성은 john

### **UPDATE** -** 기존 데이터를 수정할 때 사용**
```sql
UPDATE 테이블명
SET 열1 = 값1, 열2 = 값2
WHERE 조건;
```
- 기본 형식
```sql
UPDATE employees
SET salary = 3500
WHERE employee_id = 1001;
```
- employees테이블에서 1001의 id를 가지는 직원의 급여를 3500으로 수정

### **DELETE** **- 데이터베이스에서 데이터를 삭제(폴더 내용 삭제)**
```sql
DELETE FROM 테이블명
WHERE 조건;
```
- 기본형식
```sql
DELETE FROM employees
WHERE employee_id = 1001;
```
- employees 테이블에서 1001의 id 를 가지는 직원 정보 삭제

### DROP - 폴더 자체 삭제
```sql
drop table 테이블이름A;
```
- 테이블A 전체 삭제

### ALTER - 기존의 테이블을 유지하면서 원하는 부분만 수정
```sql
ALTER TABLE 테이블 이름
	ADD 속성이름 데이터타입
    DROP COLUMN 속성이름
    ATLER COLUMN 속성이름 데이터타입
    ADD PRIMARY KEY(속성이름);
```
- ADD 속성 추가 , DROP 속성 제거 , ATLER COLUMN 테이블의 속성의 데이터 타입 변경,
ADD PRIMARY KEY 테이블에 기본키 추가

### **집계 함수 (Aggregate Function)**
SUM() : 컬럼의 합계를 반환
AVG() : 컬럼의 평균을 반환
MIN() : 컬럼의 최소값을 반환
MAX() : 컬럼의 최대값을 반환
COUNT() : 행의 개수를 셈
COUNT(DISTINCT) : 행의 개수를 셈
```sql
SELECT mem_id, SUM(amount*price) AS "총 금액"
	FROM buy
    GROUP BY mem_id
    ORDER BY mem_id;
```


### 트랜잭션
![](https://velog.velcdn.com/images/paul04030/post/d35471fb-ab93-429f-8919-bf8c55e7d79c/image.png)

- **데이터베이스의 상태를 변경하는 하나의 논리적 작업 단위** (**최소 수행 단위**)
- 데이터베이스의 **일관성과 무결성**을 유지하기 위해 사용
- **무결성**을 유지하기 위해 **성공하거나 모두 실패하여야 한다.**
- 트랜잭션의 4가지 특성(**ACID**)
	- 원자성(성공 OR 실패), 일관성(트랜잭션 실행 전 정의된 규칙,제약 조건 준수-DB가 자동으로 검사,오류시 롤백) ,격리성 (독립적으로 실행되는 것 처럼 보장,서로 간섭 X) , 영속성 (트랜잭션의 결과가 영구 저장 > 시스템 장애나 전원손실이 있더라도) 
- **DML과 DDL 명령어**를 포함
- 데이터베이스 계정을 통해 접속하는 동시에 시작
- 트랜잭션이 종료되기 전까지 여러 SQL문을 실행하고 트랜잭션을 제어하는 명령(TCL)을 실행할 때 기존 트랜잭션이 끝나고 그 후 새로운 트랜잭션이 시작된다.
- 데이터 처리 중 오류가 발생하였을 경우 롤백,커밋으로 변경 사항을 확정하는 기능
- **세션** : 데이터베이스 접속 시작 ~ 데이터 베이스 접속 종료까지의 전체 기간(세션이 여러개 > 데이터베이스에 접속하여 사용중인 연결이 여러 개 있다) > 세션 하나에 하나 이상의 트랜잭션이 존재

![](https://velog.velcdn.com/images/paul04030/post/ed0e399a-bdd7-46f5-96c1-283bde24fb66/image.png)
활성 : 트랜잭션이 정상적으로 실행중인 상태
실패 : 트랜잭션에 오류가 발생하여 중단된 상태
철회 : ROLLBACK 연산 수행 상태
부분 완료 : 트랜잭션의 마지막 연산까지 실행 후,Commit 직전의 상태
완료 : COMMIT연산 실행한 후의 상태



### 트랜잭션 제어 명령어 : TCL
1. COMMIT -지금까지 수행한 명령어를 데이터베이스에 영구히 반영
```sql
commit
```
- COMMIT이후 새로운 트랜잭션 시작

2. ROLLBACK - 현재 트랜잭션에 포함된 명령어의 수행을 모두 취소 
```sql
rollback
```
- 바로 전의 트랜잭션 시작 지점으로 돌아감 ( 로그 파일에 저장해둠 )
- ROLLBACK 이후 새로운 트랜잭션이 시작
3. SAVEPOINT - 특정 부분에서 트랜잭션을 취소 가능(정해진 부분까지만 되돌릴 수 있다)
```sql
SAVEPOINT 세이브포인트이름;
```
- 세이브 포인트 지정법
```sql
ROLLBACK TO 세이브포인트이름;
```
- ROLLBACK형태


**예시) 은행 시스템에서 고객이 계좌에서 일정 **금액을 인출하는 상황
1.사용자가 인출 요청
2.은행 시스템이 계좌 잔액 확인
3.잔액이 충분한지 확인
4.충분한 잔액이 있을 경우,잔액에서 금액이 차감되고 해당 내역을 거래 내역에 기록
5.잔액이 부족하거나 오류가 있을 경우,인출 취소 및 오류 메세지 전송

**트랜잭션** (이 예시에서는 SELECT, UPDATE, INSERT 문을 모두 합친 것)
1.잔액 확인,차감
	 - 해당 계좌 잔액 조회 (SELECT문)
     - 잔액이 인출하려는 금액보다 많은지 확인
     - 충분한 잔액이 있을 경우, 잔액에서 인출 금액을 차감 (UPDATE문) 
2.거래 내역 기록
	- 인출한 금액과 계좌 정보를 이용하여 거래 내역 작성(INSERT문)
3.트랜잭션 완료 또는 롤백
	 - 모든 작업이 정상적으로 완료된 경우,트랜잭션을 커밋
     - 잔액 부족이나 오류가 발생한 경우, 트랜잭션을 롤백하고 이전 상태로
     
-> 만약 중간에서 오류가 발생했다면?  -> 사용자의 계좌에서 돈만 차감되고 인출은 안된 상황 등이 발생 가능
-> **결과적으로 원자성 만족** 

**다른 속성들은 어떻게 만족?**

**격리성 **
- **LOCK** : 조작 중인 데이터를 다른 세션은 조작 할 수 없도록 접근을 보류시키는 것
-> 특정 세션에서 조작중인 데이터는 트랜잭션이 완료되기 전까지 다른 세션에서 조작 할 수 없는 상태가 된다.
- **HANG** : 특정 세션에서 데이터 조작이 완료 될 때까지 다른 세션에서 해당 데이터 조작을 기다리는 현상
- **MVCC** : 데이터를 바꿀 때 바로 덮어쓰지 않고 버전(스냅샷)을 만들어 저장
-> 특정 세션에서 테이블의 데이터를 변경 중일 때 그 외 다른 세션에서는 데이터의 변경이 확정되기 전까지 변경 사항을 알 필요가 없으므로 읽는 트랜잭션은 변경 전 버전을 읽음(**읽기 일관성**)

**영속성 **
- **로그 **: COMMIT 직전 로그를 디스크에 영구 저장 >전원이 꺼져도 자동 복구 가능
- **디스크 동기화** : 메모리에 있는 내용을 디크스에 확실히 내려쓰기
- **복제** : 여러 서버에 복제
![](https://velog.velcdn.com/images/paul04030/post/a61c91f7-4dd3-4ec8-80e8-5fdf9a4dbea1/image.png)


### 무결성
- 데이터의 정확성,일관성,신뢰성,유효성을 유지하는 것을 의미
- 무결성이 유지되어야 데이터베이스에 저장된 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는 지에 대한 신뢰가 생김

#### 무결성의 종류
**개체 무결성, 참조 무결성, 고유 무결성, 비즈니스 무결성 ,NULL 무결성**
**개체 무결성** : 기본키로 선택된 필드는 빈 값(NULL등)을 허용X -> DB가 PRIMARY KEY 제약 조건 자동 검사
**참조 무결성** : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지(기본키-외래키) -> DB가 외래키 제약 조건 자동 검사
**고유 무결성(영역 무결성)** : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐 ( 값이 0 이상 ,기본값을 1 등) -> UNIQUE 제약조건으로 칼럼에 중복된 값이 들어오면 DB가 에러 발생
**비지니스 무결성** : 사용자의 업무 규칙에 따른 비즈니스적 제약 조건(사용자 정의) -> CHECK,TRIGGER(삽입/수정 시 자동 검증) 제약조건
**NULL 무결성** : 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될수 없음 -> NOT NULL 제약 조건

---
## ERD

### ERD 의 개념과 구성 요소
**데이터 모델링**- 업무 내용을 분석하여 이해하고 약속된 표기법에 의해 표현
**데이터 모델링 절차**
1. 업무 파악 (사용자 식별,데이터베이스 용도 식벽 등)
2. 개념적 데이터 모델링 ( 데이터 관의 관계 구상 -ERD 해당 (피터 첸 표기법))
![](https://velog.velcdn.com/images/paul04030/post/e9fdc36d-a20c-4711-a9c1-db838005e354/image.png)
![](https://velog.velcdn.com/images/paul04030/post/053661dd-03dd-440a-8c83-545aadc09a84/image.png)


3. 논리적 데이터 모델링(구체화된 업무 중심의 데이터 모델 만들기,상세 속성 정의,테이블의 키 지정 등-ERD 해당(정보공학 표기법))
![](https://velog.velcdn.com/images/paul04030/post/5eb8bdf9-0516-4711-8cc7-a04caf55de0a/image.png)

4. 물리적 데이터 모델링 (데이터베이스 선택,실제 테이블을 만드는 작업)



**Entity Relationship Diagram**
- **개체 관계 다이어그램** - **데이터베이스의 구조**를 시각적으로 표현하기 위해 개체와 **개체 간의 관계를 나타낸 다이어그램**
![](https://velog.velcdn.com/images/paul04030/post/9d289510-7f8a-4ac8-a636-c65d66b8fc7a/image.png)

**ERD의 장점**
- 데이터베이스 구축 용이 
- 테이블 간의 관계 파악 용이
- 디버깅 용이
- 데이터의 우선순위 파악 용이
- 테이블에 제약조건 및 데이터 타입 보기 쉬움

**구성요소 **
**개체(ENTITY)** **속성(ATTRIBUTE)** **관계(RELATIONSHIP)**

**개체(ENTITY)** 
- 정의 가능한 사물 또는 개념(다른 것과 구별되는 독립적인 객체)
- 관리하고자하는 정보의 실체
- 사각형,둥근 사각형으로 작성
- 이름은 단수형,유일한 단어,대문자로 표기
- 데이터베이스의 테이블이 엔티티로 표현
- 강한 개체:독자적으로 존재할 수 있는 개체(학생,직장인 등)
- 약한 개체:다른 개체(강한 개체)에 의존해야만 존재할 수 있는 개체(수강 신청 내역 ,월급 등) 
![](https://velog.velcdn.com/images/paul04030/post/670f01cc-caba-4c67-9743-7cb06d2004bc/image.png)


**속성(ATTRIBUTE)**
- 개체를 구성하고 있는 특성,성격,속성
- 개체를 설명하는 데이터의 최소 단위
- 타원형(동그라미) / 사각형 내부에 목록으로 작성
- 속성이름은 단수형,소문자로 표기
- 개체 이름과 겹치면 안됨
- Key Attribute - 엔터티내에서 다른 객체들과 구별할 수 있게 해주는 고유한 값을 가진 속성(기본 키, 외래 키 등)
- Composite Attribute - 독립적인 속성들이 모여서 생성된 속성
- Multivalued Attribute - 한 값 이상의 값을 가지는 Attribute
- Derived Attribute - 다른 속성에 기초한 속성
![](https://velog.velcdn.com/images/paul04030/post/c2e5918a-66d2-4a45-8d3b-520bae769b3f/image.png)

**관계(RELATIONSHIP)**
- 개체간의 관계를 의미
- 두 개체 사이에 선을 긋고 관계명칭을 기록
- 마름모 / 선으로 표기
- 부모의 키를 자식에서 PK로 사용하는지 일반 속성으로 사용하는지에 따라 선의 표기가 다름
- 실선 표현 : 강한 관계 > '식별자 관계' >자식 주식별자의 구성에 포함 >부모-자식
![](https://velog.velcdn.com/images/paul04030/post/4f367f3c-6958-4768-a5fc-6b4213512e7a/image.png)

- 점선 표현 : 약한 관계 > '비식별자 관계' > 자식 일반 속성에 포함
![](https://velog.velcdn.com/images/paul04030/post/2e090f95-7cc6-4fc6-b3aa-08fb82c81c07/image.png)

**도메인(Domain)**
- 속성의 값,타입,제약 사항 등 표현(범위)
- 성별은 M/F만 가능
- 나이는 0~150
- 생략 가능

**타입**
(문자형)
- VARCHAR(n) : n개의 글자 수를 최대 저장할 수 있는 가변 길이 문자열
- CHAR(n) :n개의 글자 수를 고정한 고정 길이 문자열 
- TEXT : 매우 긴 문자열 저장
(숫자형)
- INT : 정수
- DECIMAL(p,s) / NUMERIC: 정확한 소수(정확도 위해)
- FLOAT/DOUBLE : 부동 소수점
(날짜/시간형)
- DATE 날짜 저장
- TIME 시간 저장
- DATETIME / TIMESTAMP 날짜,시간 저장
(논리형)
BOOLEAN / BOOL > 참 OR 거짓
(기타)
JSON > JSON 그대로
BLOB >이미지,오디오,비디오 등대용량 바이너리 데이터

![](https://velog.velcdn.com/images/paul04030/post/be49be9e-877c-47a1-b108-a10e9cd6057d/image.png)

**키와 Constraint(제약조건) 표기법**

**주식별자 PK - Primary Key** : 해당 개체의 고유한 속성 값,열쇠,다이아몬드 그림으로 표시

![](https://velog.velcdn.com/images/paul04030/post/3e8fba51-4fdc-45d2-aecb-8ef29e82ed17/image.png)

**NOT NULL** : NULL을 허용하지 않으면 Not NULL 로 표기,N,NN으로 표시
![](https://velog.velcdn.com/images/paul04030/post/b93279e1-378e-4976-b8b4-d935f27798f0/image.png)


**외래 식별자 FK -Foreign Key** : 개체와 관계를 따져 표시
![](https://velog.velcdn.com/images/paul04030/post/20b4cd50-406c-41b1-a874-f0fb54951707/image.png)


**Candinality(관계 차수)**
- **엔티티들 간의 관계에 대한 추가정보**
- 한 개체에서 발생할 수 있는 발생 횟수
- **1:1(일대일)** : 양쪽 원소 모두 하나의 원소와의 관계만 존재하는 경우
![](https://velog.velcdn.com/images/paul04030/post/c12c9539-5786-4ee4-94f2-6a8252bc5bd5/image.png)

- **1:N(일대다)** : 하나의 원소가 하나 이상의 원소와의 관계가 존재하는 경우
![](https://velog.velcdn.com/images/paul04030/post/169876dd-bed2-491c-8214-7b777ac8f1b3/image.png)

- **N:M(다대다)** : 양쪽의 원소 모두 반대쪽 원소와 관계를 맺을 수 있음
![](https://velog.velcdn.com/images/paul04030/post/b8f56827-c862-405c-9a8f-8fb2e2dbc487/image.png)

**관계 참여도** : 관계선 각 끝에 기호로 표시
| : 필수 (반드시 있어야 하는 개체) 
O : 선택 (없어도 되는 개체)

**One** : 일대일 혹은 일대다 관계
**Many** : 다대다 관계
**One (and only one)** :일대일관계(하나의 row끼리만 연결된 데이터)
**Zero or one** : 일대일 혹은 일대다 관계를 가지지만 필수 조건이 아님
**One or many** : 일대일 혹은 다대다 관계,참조되는 row의 값이 불명확함
**Zero or many** : 참조하는 테이블과의 관계가 불명확한 경우

**ERD 기호&관계선**
![](https://velog.velcdn.com/images/paul04030/post/dafc49f3-a90e-48f7-bc48-06d46d28b2c0/image.png)

![](https://velog.velcdn.com/images/paul04030/post/4596d61a-0ecf-41df-9857-250cf886a69d/image.png)


### 정규화
**정규화** : **중복된 데이터를 허용하지 않게 만드는 것**

**정규화 장점**: **무결성 , 일관성 , 유연성 향상 ,DB저장 용량 줄임**

**정규화 단계**
**제 1정규화**
![](https://velog.velcdn.com/images/paul04030/post/8de151fe-f474-4e54-a718-a03dae925f8e/image.png)
속성은 더 이상 쪼갤 수 없는 원자값만 저장
->
![](https://velog.velcdn.com/images/paul04030/post/8478611b-200b-4d4d-9f5b-443c6d37f32b/image.png)
**데이터의 속성(칼럼)이 하나의 값(원자값)을 갖도록 테이블을 분해**

**제 2정규화**
제 1정규화가 진행된 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해하는 것

**완전 함수 종속이란?** - 기본키의 부분집합이 결정자가 되지 않는 것
![](https://velog.velcdn.com/images/paul04030/post/c84d97c0-f739-41b3-a01f-6b2fd42aecf2/image.png)
**복합 기본키**가 학생번호,강좌이름
강좌 이름이 강의실을 결정하는 강의실의 PK가 될 수 있음.
![](https://velog.velcdn.com/images/paul04030/post/84bbe92a-e4d4-4092-8de2-c581766feb78/image.png)



**제 3정규화**
제2 정규화가 완료된 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분해

**이행적 종속이란?**
A->B,B->C가 성립할 때 A->C가 성립되는 것

![](https://velog.velcdn.com/images/paul04030/post/81cb5028-7121-4ff8-8c85-832ae733043f/image.png)

501 학생이 강좌를 다른 강좌로 바꿨을 때 수악료 까지 변경해야함

![](https://velog.velcdn.com/images/paul04030/post/3161f792-7c40-41c2-9e87-0a6899518084/image.png)
수강료에 바꾼 강좌 이름이 존재한다면 계절수강의 강좌이름만 바꾸면 되고
바꾼 강좌 이름이 존재하지 않는다면 추가만 해주면 그 이후부터는 편리

**기본적으로 제 3정규화까지만 진행**
-> 개체증가,개체 사이 관계증가,조회 성능 하락 등 문제가 발생 할 수 있으므로


**그 이후의 정규화**


**BCNF 정규화**
제3 정규화를 진행한 테이블에 대해 모든 결정자(다른 속성 결정)가 후보키가 되도록 테이블을 분해하는 것
**제 4정규화**
제 4정규화는 BCNF를 만족하는 테이블에 대해, 다치 종속을 제거하는 것

다치 종속이란?
같은 테이블 내의 독립적인 두 개 이상의 컬럼이 또 다른 컬럼에 종속되는 것
A -> B인 의존성에서 단일 값 A와 다중 값 B가 존재한다면 다치 종속이라 하고 A->>B로 표기

**제 5정규화**
제 5정규화는 4정규형을 만족하는 테이블에 대해 조인 종속을 제거하는 것을 의미
조인 종속이란?
하나의 릴레이션을 여러 개의 릴레이션으로 분해했다가, 다시 조인했을 때 데이터 손실이
없고, 필요없는 데이터가 생기는 것

## 실습 과제
![](https://velog.velcdn.com/images/paul04030/post/c6432aac-1292-4871-a296-2d80e622c85e/image.png)


