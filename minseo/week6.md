# <font color="yellow"> 6주차 </font> 
## 1. HTTP
![alt text](image-1.png)
참고 ) **OSI 7계층** : 네트워크 통신을 7개의 계층으로 나눈 이론  
**응용 계층(application layer,presentation layer,session layer)**- 사용자와의 상호작용 서비스를 제공하는 계층 (http,smtp:이메일)  
**전송 계층(Transport Layer)**-신뢰성 있는 데이터 전송 (TCP:포트번호 이용한 프로세스 간 통신)  
**네트워크 계층(Network Layer)**:목적지까지 패킷전달,라우팅 (IP,ARP:IP주소>MAC주소-물리주소)  
**데이터 링크 계층(DataLink Layer)**:mac주소 기반 전송,오류검출  
**물리계층(Physical Layer)**:비트단위의 신호 전송  

![alt text](image-3.png)
**캡슐화(응용>물리) -> 역캡슐화(물리>응용)**

참고) HTML  
![alt text](image-2.png)
> 하이퍼링크로 연결된 문서들
- **Hyper Text Markup Language**
- HyperText 란? : 단순한 텍스트를 넘어 참조(하이퍼링크)를 통해 다른 텍스트나 문서로 즉시 이동할 수 있는 비선형적인 텍스트
- markup 이란? : 문서의 구조와 내용을 정의하는 태그를 의미
- language : 정보를 컴퓨터가 이해할 수 있는 방식으로 작성하는 표준 언어
- hypertext를 표시하기 위해 구조를 정의하는 언어
![alt text](image-4.png)

### HTTP란?
- **Hyper Text Transfer Protocol**
- Protocol : 통신규약(절차)
- 인터넷에서 클라이언트(요청자)와 서버(데이터를 가진 쪽)이 서로 대화하는 방식을 정해 놓은 것
- http가 처음 만들어졌을 때 하이퍼텍스트 전송을 위해 만들어짐
- 현재는 json,이미지,영상,파일 등 모든 종류의 데이터를 주고받는 통신 규약
- IETF World Wide Web Consortium에서 공식적인 기술 표준으로 만듬

포트번호:80

### http vs html
- html은 웹 페이지의 구조와 내용을 구성하는 마크업 언어
- http는 서버와 브라우저 간의 데이터를 주고받는 통신규약
- html으로 콘텐츠 구조화를 시키고 이를 통신하는 규칙이 http
### HTTPS란?
![alt text](image-6.png)
- HTTPS-HyperText Transfer Protocol **Secure**  
- 데이터가 암호화되지 않아 정보가 인터넷 상에 노출될 수 있는 HTTP와 달리 전송 계층에서 SSL,TLS으로 암호화를 적용해 보안이 추가된 HTTP
- 속도는 HTTP보다 조금 느려질 수 있다(실제 체감속도 차이는 거의 없다)
- 주소창에 자물쇠 아이콘 🔒이 HTTPS가 적용되었음을 의미

포트번호 443

참고)   
SSL
- SECURE SOCKET LAYER :인터넷에서 데이터를 안전하게 주고 받기 위한 암호화 프로토콜   

![alt text](image-5.png)

RECORD 프로토콜(암호화,무결성 검사,분할,기밀성)  - 실제 데이터를 안전하게 처리하고 전송
1) 데이터 단편화(fragmentation) 
2) 압축(선택)
3) MAC(메세지 인증 코드)
4) 메세지와 MAC을 대칭키 암호화
5) TLS/SSL헤더를 앞에 추가

Handshake 프로토콜
1) 클라이언트에 의해 논리적 연결
2) 서버 인증,키교환
3) 클라이언트 인증,키교환
4) ChangeCipherSpec-암호화 준비 완료 상태 전달  

Change Cipher Spec 프로토콜
- Cipher Suite(암호 알고리즘) 갱신

Alert 프로토콜 
- 경고,사고 알림

TLS
- TRANSPORT LAYER SECURITY:SSL을 IETF 표준문서로 작성한 것
- 보안 알고리즘 강화,핸드셰이크 간소화
- Heartbeat 프로토콜(활성 상태 확인) 추가
- application 프로토콜(응용 메세지 처리) 추가

---
## 2. HTTP 구조와 작동원리
**웹의 정의**
- 월드 와이드 웹(www)의 줄임말로 인터넷을 통해 문서,이미지,영상 등 다양한 정보를 연결하고 접근할 수 있는 거대한 정보 네트워크
- 인터넷으로 연결된 환경에서 HTML문서를 주고받으며 작동하는 시스템

**웹의 동작 방식**
웹은 클라이언트–서버 구조(Client–Server Model)를 기반으로 작동
1. 사용자가 웹 브라우저(클라이언트)에 웹 주소(URL)를 입력
2. 브라우저는 해당 URL에 포함된 서버 주소(도메인)로 요청(Request)을 보냄 (DNS(DOMAIN NAME SYSTEM) IP주소 <->도메인 주소)
3. 웹 서버(Web Server)는 요청받은 HTML 문서, 이미지, 영상 등의 자원(Resource)을 찾아
4. 브라우저로 응답(Response)을 보냅니다.
5. 브라우저는 전달받은 HTML, CSS, JavaScript를 렌더링(Rendering 시각적 표시)
6. 우리가 보는 웹페이지 형태로 화면에 표시

### 웹 주소의 구성
- URI / URL / Base URL / Endpoint  

![alt text](image-7.png)

**URI**  - Uniform Resource Locater 통합 자원 식별자 
- 인터넷에 있는 자원을 어디에 있는지 자원 자체를 식별하는 방법
- 인터넷 상의 자원을 고유하게 **식별하는** 문자열,자원의 위치나 이름을 나타냄
- URL,URN을 모두 포함
 
**URL** - Uniform Resource Locator 자원 위치 지정자  
- 자원이 **어디 있는지** 위치를 알려주기 위한 규약(접근법)
- 웹 페이지를 찾기 위한 주소
- 크게는 프로토콜,도메인 이름,경로로 구분
- 스키마에 따라 변형

|http://www.ex.com/html/default.js|||
|---|---|---|
|스키마(scheme)|http|프로토콜 명시 - https,http,ftp등|
|호스트|www|서버이름,주소 명시|
|도메인|ex.com|서버를 운영하는 조직 명시|
|경로(디렉토리)|/html|서버 내의 디렉토리 명시|
|문서명과 파일형식|/default.js|파일 명시|

|https://www.example.co.kr:8080/products/search?id=123&sort=popular#details|||
|---|---|---|
|스키마|https|통신 방식 (규칙) |
|호스트|www.example.co.kr|서버 주소 (도메인) |
|포트|:8080|서비스 입구  |
|경로|/products/search|서버 내 자원 위치 |
|쿼리,매개 변수|?id(변수)=123(값)...|서버에 전하는 세부 조건,구체적 요청| 
|프래그먼트|#details|페이지 내 특정 위치|

**URN** - Uniform Resource Name 통합 자원 이름
- 자원의 위치와 상관없이 자원의 이름 식별

![alt text](image-8.png)

![alt text](image-13.png)
**Base URL** 
상대 URL의 기준이 되는 **기본 경로**
**역할**
경로 일관성
URL 변환
코드 간소화 
인증서,API 연동 시 필수

**Endpoint**
특정 기능이나 데이터를 요청

**쿼리 파라미터**
?로 시작 키=값 쌍으로 서버에 추가 정보 전달  
GET 요청에서 주로 사용
검색 ,필터 ,페이지네이션 등 조건부 데이터 전달에 사용

### HTTP 요청 구조
![alt text](image-9.png)
### **구성요소**  
**Start Line**
- HTTP 메소드:요청의 종류 
- URL-요청 대상 리소스 주소
- protocol 버전(http 등)

**요청 HTTP 헤더** :요청에 대한 추가 정보  
- Host :요청 호스트 이름과 포트번호
- User-agent :클라이언트 프로그램 정보
- Accept : 클라이언트가 처리 가능한 응답 형식
- Referrer :이전 웹 페이지의 주소
- Cookie : 서버로부터 전송되었던 쿠키
- Accept-Language: 서버가 제공할 수 있는 언어 명시

**Empty Line 및 Body**:빈줄 및 메세지 본문(데이터)


- HTTP 메소드 (GET/POST/PUT/PATCH/DELETE)

- GET -데이터 조회,검색
- HEAD -본문 없이 헤더 정보만 반환(GET과 유사,리소스 변경 여부 등을 확인하는데 사용)
- POST -서버에 데이터 전송,리소스 생성/변경
- PUT -기존 데이터 수정(업데이트)
- DELETE -데이터 삭제
- TRACE -서버한테 보낸 요청 메세지 반사 등
- PATCH - 리소스의 특정부분 변경

### HTTP 응답 구조
![alt text](image-10.png)
### 구성 요소   

**Start line**
- 프로토콜 버전
- 응답 상태 코드  
1xx(정보 응답),2xx(요청 성공),3xx(서버가 다른 곳에 있을 때),4xx(클라이언트 오류),5xx(서버 오류)
- 상태메세지 :상태코드와 함께 전달되는 메세지

**응답 HTTP 헤더**  
웹서버 종류,인증방식,Set-Cookie 등 응답에 대한 추가 정보  

**Empty Line 및 Body**
메세지 본문,실제 데이터 (서버->클라이언트)

- HTTP Status Code(200,201,400,404,500...)

![alt text](image-11.png)

- 200(성공): 서버가 요청을 제대로 처리
- 201(작성됨): 성공적으로 요청되었으며 서버가 새 리소스를 작성
- 400(Bad Request, 잘못된 요청): 서버가 요청의 구문을 인식하지 못함
- 404(Not Found, 찾을 수 없음): 서버가 요청한 페이지를 찾을 수 없다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 표시
- 500(내부 서버 오류): 서버에 오류가 발생하여 요청을 수행할 수 없음

---
## 3. API

### API란?
- Application Programming Interface 
- 정의 및 프로토콜 집합을 사용하여 프로그램과 프로그램(고유한 기능을 가진 소프트웨어) 사이의 상호작용을 정해진 규칙에 따라 가능하게 해주는 인터페이스(통신,서비스 규약)
- 한 시스템이 다른 시스템의 기능을 사용할 수 있도록 도와주는 '중개자','소통창구' 역할
- 음식 배달 앱에서 지도를 띄우거나 소셜 로그인 기능을 이용할 수 있는 것
- 사용자와 개발자 모두에게 편리한 환경을 제공
- 클라이언트와 서버 측면에서 설명

**활용 사례**  
>소셜 로그인 네이버 카카오 구글 계정을 통해 다른 웹사이트에 로그인  
지도 기능   
날씨 정보 제공  
간편결제 기능  
물류 추적 기능  
챗봇 문자 메세지 발송 이메일 자동화 시스템

### API의 역할과 필요성
1. 데이터 공유 - 서로 다른 시스템 간 데이터를 주고 받는 통로 역할
2. 자동화 - API를 통해 자동으로 처리
3. 확장성 - 새로운 기능을 간단히 추가 가능(조립식)

### API의 종류
![alt text](image-17.png)  
**크게 공개 범위 기술구조(아키텍처)에 따라 나뉜다**
#### 공개 범위에 따른 API

1. 오픈형 인터페이스 (OPEN API) - 누구에게나 공개되어 자유롭게 사용 가능 (정부 공공데이터 - 교통 정보,네이버의 검색 기능)
2. 비공개 시스템 연동 방식 (PRIVATE API)-기업 내부에서만 사용,외부에 노출 x (쇼핑물 재고 관리 ,결제 모듈)
3. 제휴 기반 연동 방식 (PARTNER API)-특정 파트너에게만 제공(대형 배달 플랫폼-프랜차이즈 업체에게만 주문 및 배송 정보 연결)
4. 복합 API -두개 이상의 서로 다른 API를 결합하여 복잡한 시스템 요구 사항이나 동작 처리

#### 기술구조(아키텍처) 방식에 따른 API

SOAP API -단순 객체 접근 프로토콜 사용, XML을 사용하여 메세지 교환 ,메세지 구조가 엄격하고 보안성이 뛰어남.(과거에 많이 사용,금융권이나 공공기관에서 사용,표준화된 설계 데이터의 신뢰성과 일관성이 높다) 

RPC API -원격 프로시저(함수) 호출 ,클라이언트가 서버에서 함수나 프로시저 완료하면 서버가 출력을 클라이언트로 다시 전송

Websocket API -JSON 객체를 사용하여 데이터를 전달하는 최신 웹 API개발, 양방향 통신 지원,서버가 클라리언트에 콜백 메세지를 전송할 수 있어 효율적

REST API - 웹에서 볼 수 있는 가장 많이 사용되고 유연한 API. 웹 환경에서 효율적으로 데이터를 교환, HTTP 요청을 통해 작동, 서버가 클라이언트 입력을 사용하여 내부 함수를 시작,출력 데이터를 JSON 형식으로 응답 전달,URL을 통해 특정 자원에 접근

### 참고) 관련 용어
**API 통합**   
클라이언트와 서버 간의 데이터를 자동으로 업데이트하는 소프트웨어 구성 요소  
EX) 휴대폰 이미지 갤러리에서 클라우드로 데이터 자동 동기화, 다른 시간대 여행 시 노트북에서 시간 및 날짜 자동 동기화

**OpenAPI (OpenAPI Specification)** -Swagger  
API 명세서

**GraphQL**  
GraphQL은 API용으로 특별히 개발된 쿼리 언어, 클라이언트에게 요청한 데이터만 제공해 효율적, API를 빠르고 유연하며 개발자 친화적으로 만들도록 설계.복잡한 구조의 데이터를 처리할 때 유용,REST의 대안으로서 GraphQL은 프런트엔드 개발자에게 단일 GraphQL 엔드포인트로 여러 데이터베이스, 마이크로서비스 및, API를 쿼리할 수 있는 기능 제공. 

#### API 생성 방법
1. API 계획 
2. API 빌드
3. API 테스트  
4. API 문서화  
5. API 마케팅 

#### API사용법 
1. OpenAPI 명세서 등 API 설명서 확인(BASE URL + ENDPOINT)
2. 인증을 필요로 하는 키 발급 
3. 데이터를 전달하는 요청 (HTTP 요청 등)  
4. 이에 대한 응답 (JSON 등)
5. 받은 데이터를 처리하는 과정(파싱-객체나 변수로 변환하는 과정)

---
## 4. REST API
![alt text](image-21.png)
### - REST
  - 의미
    - Representational State Transfer(표현 상태 전송) 아키텍처("분산 시스템"을 위한 HTTP기반 소프트웨어 아키텍처) 스타일을 따르는 API
    - 웹 기반 통신에서 자원을 정의하고 자원에 대한 주소를 사용하여 정보를 주고받는 방법
    - 자원의 상태를 CRUD(CREATE,READ,UPDATE,DELETE) 작업을 통해 관리

  - **구성 요소**   
 **1. 자원(리소스)** - API가 다루는 데이터,
  URI로 정의,처리되는 대상(JSON,XML,이미지,비디오 등)  
 **2. 메소드(행위,verb)** - HTTP 메소드로 정의 POST(생성) GET(조회) PUT(전체수정/덮어쓰기) PATCH(부분수정) DELETE(삭제) 등 자원 조작
 **3. 메세지(표현)** - 어떤 형식으로 자원을 주고 받을지를 정하는 것.JSON(JavaScript Object Notation) 형식이 사실상 표준

### **RESTful 설계 규칙**
![alt text](image-20.png)
REST 아키텍처의 원칙을 잘 지켜서 설계된 API 

균일한 인터페이스(인터페이스 일관성) :
1. 동일한 리소스에 대한 모든 API 요청은 요청의 출처에 관계없이 동일하게 표시  
2. 각 메세지의 내용을 이해하기 위해 추가적인 정보 불필요
3. 메세지를 통한 자원 조작
4. API 응답에 관련된 다른 자원으로의 링크가 포함(HATEOAS)

클라이언트 - 서버 분리 : 클라리언트가 알아야 하는 정보는 요청된 리소스의 URI,세션관리,사용자 인증 등 담당   
서버는 데이터 저장과 관리 담당
API제공,비즈니스 로직 처리 담당

무상태(Stateless) : 서버클라이언트 요청과 관련 데이터 저장 x,모든 요청은 작업을 수행하는 데 필요한 모든 정보를 포함  > 서버의 부담 줄고 응답 빠르게 처리 가능

캐시 가능성(cashable) : 
서버는 응답에 캐시 가능 여부를 명시,클라이언트나 서버 측에서 리소스를 캐시(임시저장)할 수 있어야 한다 > 성능 최적화,대역폭 절약(Last-Modified 헤더 E-Tag 활용)

코드 온 디맨드(선택사항) :서버가 실행 가능한 코드를 클라이언트에게 보내 기능 확장 가능

계층화된 시스템(계층 구조) :
클라이언트는 엔드서버와 직접 통신하는 것 처럼 동작(보안,시스템 확장성 증대),서버의 내부 구조 알 필요 없이 API 사용 가능 > 유지 보수 통신 효율적

자체표현 : 요청 메세지만으로도 쉽게 이해 가능

JSON 응답 형식 유지 :일반적으로 JSON을 응답 형식으로 사용

### HTTP 메서드와의 관계
![alt text](image-19.png)
REST는 HTTP 메소드를 사용
GET 리소스 조회  
POST 새 리소스 생성  
PUT  리소스 전체 수정  
PATCH  리소스 일부 수정  
DELETE  리소스 삭제

HTTP 상태 코드 활용 
- 200(성공): 서버가 요청을 제대로 처리
- 201(작성됨): 성공적으로 요청되었으며 서버가 새 리소스를 작성
- 400(Bad Request, 잘못된 요청): 서버가 요청의 구문을 인식하지 못함
- 404(Not Found, 찾을 수 없음): 서버가 요청한 리소스를 찾을 수 없다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 표시
- 500(내부 서버 오류): 서버에 오류가 발생하여 요청을 수행할 수 없음

### REST API의 장단점

**장점**
- HTTP 프로토콜 인프라 활용 가능(HTTP 캐싱,언어 기술 종속 X > 확장성)
- 유저 관리의 용이성 
- 직관성 및 가독성
- 무상태성 > 서버구조 단순,확장 쉬움
- 다양한 데이터 포맷 지원 (JSON,XML > 쉽게 처리 가능)

**단점**
- 엄격한 표준 존재 X
- 데이터 낭비,부족 > 필요한 정보보다 많이 받거나 적게 받는 경우 존재
- 사용할 수 있는 메소드에 제한
- 엔드포인트 관리 복잡성 

---
## 5. 데이터 포맷
### XML
#### **XML이란?**  
- Extensible Markup Language 
- 확장 가능한 마크업 언어  
- 자체적으로 컴퓨팅 작업 수행 불가
- 태그 기반의 계층 구조(트리구조) 로 표현
- 데이터의 구조적 저장과 전송에 중점을 둔 언어
- .xml 확장자로 저장할 수 있는 텍스트 기반 문서

![alt text](image-14.png)

#### 기본 구조와 태그 사용 방식

![alt text](image-15.png)

**XML 태그** 
- XML 문서의 기본 구성 단위(요소) 
- 시작 태그와 종료 태그로 구분  
>   < xml>    
 ...  
< /xml>

**XML선언 Prolog** 
- XML 자체에 대한 정보
- XML 문서의 시작 부분에 위치
- 문서의 버전과 인코딩 방식 지정
> < ?xml version="1.0" encoding="UTF-8"?>

**XML 속성**
- 추가 정보 제공
- 이름 = 값 쌍으로 구성
>< person age="22">  
< /person>

**XML 콘텐츠(텍스트)**
- 요소의 시작 태그와 종료 태그 사이에 있는 실제 내용   
>< name>Charlie< /name>  
< name>Steve< /name>  

**CDATA 섹션**
- 특수 문자나 마크업을 포함한 텍스트를 안전하게 포함시키기 위한 영역
> < message>< ![CDATA[<greeting>Hello, world!</greeting>]]>< /message>

**주석**
-< !-- ... -->로 표시
> < !-- comment -->

**트리 구조**
- 부모(parent) 요소는 여러개의 자식(child) 요소를 가질 수 있음
- 자식 요소는 단 하나의 부모 요소를 가질 수 있음
- 형제 요소(sibling)는 같은 트리 레벨에 존재하는 요소
- 루트 노드 : 모든 요소의 조상 요소

#### 특징
- 비즈니스 간 트랜잭션 지원 (모든 정보 전자적으로 공유 가능)
- 데이터 무결성 유지(데이터 무결성,참조 무결성,문법적 무결성,데이터 일관성)
- 검색 효율성 향상(태그 기반 검색 엔진)
- 유연한 애플리케이션 설계
- 구조화된 데이터 표현
- 다국어 지원
- 문법 엄격
- 데이터 재사용 간단

**활용 예시**
- 데이터 전송
- 웹 애플리케이션(데이터에 구조 제공)
- 설명서 (기술 문서 구조 정보)
- 데이터 유형 (프로그래밍 언어에서 XML 데이터 유형 지원)
- 웹 서비스 및 API
- 설정 파일

참고)  
**XML 스키마** -XML 파일 구조에 대한 몇 가지 규칙이나 제한을 설명하는 문서
EX) 문법 규칙,데이터 무결성에 대한 제약 조건

**XML 구문 분석기**
XML 문서 처리,데이터 추출
문법 검증,특정 XML 스키마 검증

### JSON
#### JSON이란?
- JavaScript Object Notation 
- 자바스크립트 객체 표기법
- 텍스트 기반 데이터 교환 형식
- 키와 값 쌍으로 정보 표시
- 중괄호를 사용하여 표현,쉼표로 속성 구분
- 자바스크립트 언어의 문법을 빌려온 데이터 형식

#### 기본 구조와 표현 방식
![alt text](image-16.png)
**객체**  
중괄호 {}로 둘러싸인 키-값 쌍의 집합  
키:문자열 " "로 표시 ,문자 숫자 특수문자 포함 가능  
값:다양한 타입(문자열,숫자,배열,객체,불린,null 등)  
키-값 쌍은 : 콜론으로 구분  
각 키-값 쌍은 ,로 구분
> {  
  "키1": "값1",  
  "키2": "값2"  
  }

**배열**  
대괄호 []로 둘러싸인 값의 순서 있는 목록  
배열의 요소는 다양한 타입(배열,객체,키만 표시도 가능)  
, 쉼표로 구분

#### 특징
- 가독성 높고,가벼움
- 빠른 파싱과 생성
- 대부분의 프로그래밍 언어에서 지원
- HTTP API의 사실상 표준
- 중첩 구조 지원
- 주석 불가능
- 날짜 타입 X
- 함수 표현 불가
- 큰 숫자 처리 불리

**활용 예시**
1. API 통신
2. 설정파일
3. NoSQL 데이터베이스
4. 로깅(데이터 구조를 JSON포맷으로 변환해 로그로 기록하는 방식)

### XML VS JSON 
유사점
- 데이터 직렬화 형식

|항목|XML|JSON|
|---|---|---|
|구조 표현|트리구조, 태그 기반|키-값 페어, 중괄호 기반|
|무게/용량|더 큼|더 작음(태그 방식 보다 데이터 크기가 작고 간결)|
|인간 가독성|높음 (형식화)|비교적 높음|
|문서타입 정의 |있음 (엄격함)|없음/약함|
|사용 분야|문서, 설정, 통신|웹, API, 앱 데이터|
|엑셀 연동|내부 구조 (xlsx 등)|직접 저장은 어려움 (외부 변환 필요)|
|구문 분석|XML 구문 분석기 사용(복잡)|JavaScript 함수(빠름)|
|데이터 유형 지원|복잡한 데이터 유형 지원|문자열,숫자,객체 등 한정된 범위의 데이터 유형만 지원|
|보안|비교적 불안전|비교적 안전|

### REST API에서 주로 사용되는 데이터 포맷
JSON 데이터 포맷 주로 사용  
**선호 이유**   
경량성,빠른 속도,웹 친화성(자바스크립트와 호환성)

XML - REST API 사용되긴 하나 SOAP API등에 주로 사용

---
## 6. 웹 환경에서의 API요청
### 브라우저에서 API요청이 이루어지는 과정
1. 사용자의 클릭,페이지 로드 등(이벤트 발생)
2. JavaScript 코드에서 fetch(),axios 등 HTTP 요청 라이브러리(함수) 사용해 요청 생성
3. 브라우저가 요청을 API 서버로 전송(DNS 해석,TCP연결)
4. 서버가 요청을 받고 처리(데이터 베이스 조회,비즈니스 로직 실행)

### fetch /async-await

**비동기 API 요청 처리 방법**

비동기 API란?   
 클라이언트와 서버 간의 요청,응답 처리를 동시에 병렬로 처리 할 수 있도록 설계된 API방식
- 서버 부하 분산(자원 효율적으로 처리)
- 중복 호출 방지(로직 필요)

promise란?  
자바스크립트에서 비동기 작업의 완료 또는 실패를 나타내는 객체

fetch() > 내장 함수,API 요청 보냄,promise 반환

1. fetch().then() 방식 (콜백 함수 사용)

- then() 을 연결해 비동기 처리 순서 지정
- .catch()로 오류 처리
- 콜백 함수가 많아질 수 있음
![alt text](image-24.png)


2. async/await 방식 >키워드   
- async 함수에서 await 키워드를 사용하면 fetch응답이 올 때 까지 제어권이 넘어가 브라우저는 다른일을 처리  
- try-catch 를 사용해 오류 처리 가능
- fetch() 실행이 끝날 때까지 기다렸다가 (await) 다음 코드 실행
- 콜백 함수가 많아지는 것을 방지
![alt text](image-23.png)

다른방법 Promise,axios 등

### CORS  > 더 자세히 알아보기.
CROSS ORIGIN RESOURCE SHARING - 교차 출처 리소스 공유

쿠키는 도메인 별로 관리

SOP:기본 보안 정책 - 같은 도메인+포트 에서만 자원 공유 가능 (자원 분리 정책)
-> 문제점: 크롤링(서버에서 데이터 가져오기) 등

브라우저는 기본적으로 같은 출처의 리소스만 접근할 수 있는데 브라우저가 자신의 출처가 아닌 다른 어떤 출처로부터 자원을 로딩하는 것을 허용하도록 서버가 허가 해주는 HTTP헤더 기반 메커니즘(브라우저의 보안 정책)

-> 다른 출처 (CROSS ORIGIN)으로 요청을 보낼 때 서버에게 허락을 맡는 웹 보안 규칙

**역할**
- API 통신 지원
- 보안 강화
---
## Postman 실습
1. 키 받기
![alt text](image-25.png)

2. url , 키 입력 
![alt text](image-26.png)

